#! /bin/bash

# TODO: when the refactor is ready these won't be necessary, and will prevent proper output.
set -e
set -o pipefail

# import methods
source "${BASH_SOURCE%/*}/__frzr" "$@"

main() {
	#TODO Utilize the state machine to manage the individual proccesses to send signals to external monitors
	## Signals
	#TASK_STATE="" # The current state of the state machine
	#TASK_MSG="" # TASK_MSG will be read by external tools. EX TASK_MSG="Preparing user directory"
	#TASK_TRACKER=0 # TASK_TRACKER will be used to signal back that the current TASK_MSG in queue is handled or not 0 = Pending 1 = Completed
	#TASK_ERROR=0 # Signal to let listeners know that the task had an error.
	#TASK_ERROR_MSG="" # Error message. EX: "Unexpected I/O errors found during write"
	#TASK_WARNING=0 # Signal to let listeners know there is a warning
	#TASK_WARNING_MSG="" # Warning message. EX: "BTRFS filesystem was supposed to be locked, but it was already unlocked. Continuing.."

	FRZR_CHECK_UPDATE=0
	FRZR_STEAM_PROGRESS=0
	FRZR_SOURCE=""
	FRZR_PARAMS=""

	local RUNNING=true
	local STATE="CHECK"
	while $RUNNING; do
		case "$STATE" in
		"CHECK")
			TASK_STATE="CHECK"
			TASK_MSG="Checking for root privileges"
			if [ $EUID -ne 0 ]; then
				TASK_ERROR=1
				TASK_ERROR_MSG="$(basename $0) not run as root"
				STATE="FAIL"
				continue
			fi

			TASK_MSG="Checking is system has booted via UEFI"
			check_uefi_result=$(check_uefi)
			if echo "${check_uefi_result}" | grep -Fqx 'ERROR'; then
				TASK_ERROR=1
				TASK_ERROR_MSG="UEFI boot check failed: ${check_uefi_result}"
				STATE="FAIL"
				continue
			fi
			
			# Check if any updates are available and preserve FRZR parameters
			while (("$#")); do
				case $1 in
				--check)
					FRZR_CHECK_UPDATE=1
					shift
					;;
				--steam-progress)
					FRZR_STEAM_PROGRESS=1
					shift
					;;
				-* | --*)
					TASK_ERROR=1
					TASK_ERROR_MSG="Unknown argument $1"
					STATE="FAIL"
					;;
				*)                               # preserve positional arguments
					FRZR_PARAMS="${FRZR_PARAMS}$1 " # Use trailing space for the match below
					shift
					;;
				esac
			done

			STATE="BEGIN"
			;;
		"BEGIN")
			TASK_STATE="BEGIN"
			# keep only the first param as source
			FRZR_SOURCE="${FRZR_PARAMS%% *}"

			MOUNT_PATH=/tmp/frzr_root

			# Make sure the frzr_root is mounted during the deployment procedure
			# this code is based on the fact that when a btrfs filesystem is created
			# the default subvolid that is created contextually has the ID set to 256
			# also as a matter of fact in btrfs is impossible to change subvolumes IDs
			if ! mountpoint -q ${MOUNT_PATH} && ls -1 /dev/disk/by-label | grep frzr_root > /dev/null; then
				TASK_MSG="Preparing '${MOUNT_PATH}' to be used as the main subvolume mount path..."
				mkdir -p ${MOUNT_PATH}
				mount -L frzr_root -t btrfs -o subvolid=5 ${MOUNT_PATH}
				sleep 5
			fi

			if mountpoint -q ${MOUNT_PATH} && ls -1 /dev/disk/by-label | grep frzr_root > /dev/null; then
				DEPLOY_PATH=${MOUNT_PATH}/deployments

				TASK_MSG="Preparing '${DEPLOY_PATH}' to be used as the deployment destination path..."

				mkdir -p ${DEPLOY_PATH}

				# Make sure DEPLOY_PATH exists
				if [ ! -d "${DEPLOY_PATH}" ]; then
					TASK_ERROR=1
					TASK_ERROR_MSG="Could not bind ${EFI_MOUNT_PATH} to frzr_efi (boot) partition"
					STATE="FAIL"
					continue
				fi

				local deploy_systemd_boot_cfg="frzr.conf"

				TASK_MSG="Preparing '${DEPLOY_PATH}' to be used as the deployment destination path..."

				# Make sure the EFI partition is mounted during the deployment procedure
				EFI_MOUNT_PATH="${MOUNT_PATH}/efi"

				TASK_MSG="Preparing '${EFI_MOUNT_PATH}' to be used as the EFI System path..."

				if ! mountpoint -q ${EFI_MOUNT_PATH} && ls -1 /dev/disk/by-label | grep frzr_efi >/dev/null; then
					mkdir -p ${EFI_MOUNT_PATH}
					mount -L frzr_efi ${EFI_MOUNT_PATH}
					sleep 5
				fi

				# Check the "EFI System" partition is actually mounted
				if mountpoint -q ${EFI_MOUNT_PATH} && ls -1 /dev/disk/by-label | grep frzr_efi >/dev/null; then
					BOOT_CFG="${EFI_MOUNT_PATH}/loader/entries/${deploy_systemd_boot_cfg}"
					STATE="DOWNLOAD"
				else
					TASK_ERROR=1
					TASK_ERROR_MSG="Could not bind ${EFI_MOUNT_PATH} to frzr_efi (boot) partition"
					STATE="FAIL"
				fi
			else
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not bind ${MOUNT_PATH} to frzr_root main subvolume"
				STATE="FAIL"
			fi
			;;
		"DOWNLOAD")
			TASK_STATE="DOWNLOAD"
			# Check if source needs updated or needs to be created for the first time
			if [ ! -z "$FRZR_SOURCE" ] && [ "$FRZR_SOURCE" != " " ] && [ $FRZR_CHECK_UPDATE -eq 0 ] && [ $FRZR_STEAM_PROGRESS -eq 0 ]; then
				echo "$FRZR_SOURCE" >"${MOUNT_PATH}/source"
			fi

			if [ -e "${MOUNT_PATH}/source" ]; then
				SOURCE=$(cat "${MOUNT_PATH}/source" | head -1)
			else
				echo "WARNING: source wasn't specified"
			fi

			if [ "${local_install}" == true ]; then
				mkdir tmp_source
				mount -o rw -L FRZR_UPDATE /root/tmp_source
				FILE_NAME=$(basename /root/tmp_source/*.img.tar.xz*)
				NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
				SUBVOL="${DEPLOY_PATH}/${NAME}"
				IMG_FILE="/root/tmp_source/${FILE_NAME}"
			elif [[ "$FRZR_SOURCE" == *".img.tar.xz" ]]; then
				FILE_NAME=$(basename ${FRZR_SOURCE})
				NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
				SUBVOL="${DEPLOY_PATH}/${NAME}"
				IMG_FILE=${FRZR_SOURCE}
			elif [[ "$FRZR_SOURCE" == *".img" ]]; then
				FILE_NAME=$(basename ${FRZR_SOURCE})
				NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
				SUBVOL="${DEPLOY_PATH}/${NAME}"
				IMG_FILE=${FRZR_SOURCE}
			else
				REPO=$(echo "${SOURCE}" | cut -f 1 -d ':')
				CHANNEL=$(echo "${SOURCE}" | cut -f 2 -d ':')

				RELEASES_URL="https://api.github.com/repos/${REPO}/releases"

				IMG_URL=$(curl --http1.1 -L -s "${RELEASES_URL}" | get_img_url "${CHANNEL}")

				if [ -z "$IMG_URL" ] || [ "$IMG_URL" == "null" ]; then
					if curl --http1.1 -L -s "${RELEASES_URL}" | grep "rate limit" >/dev/null; then
						TASK_ERROR=1
						TASK_ERROR_MSG="GitHub API rate limit exceeded"
						STATE="FAIL"
					else
						TASK_ERROR=1
						TASK_ERROR_MSG="No matching source found"
						STATE="FAIL"
					fi

					continue
				fi

				FILE_NAME=$(basename ${IMG_URL})
				NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
				BASE_URL=$(dirname "${IMG_URL}")
				CHECKSUM=$(curl --http1.1 -L -s "${BASE_URL}/sha256sum.txt" | cut -f -1 -d ' ')
				SUBVOL="${DEPLOY_PATH}/${NAME}"
				IMG_FILE="${MOUNT_PATH}/${FILE_NAME}"

				if [ -e ${SUBVOL} ]; then

					# Only allow deleting the subvolume if we are booted in the installer.
					if [ "$UPGRADE" -eq 0 ]; then
						MSG="${NAME} is already installed, would you like to delete this and re-deploy?"
						if (whiptail --yesno "${MSG}" 10 50); then
							echo "deleting ${NAME}..."
							btrfs subvolume delete ${SUBVOL}
							rm -rf "${EFI_MOUNT_PATH}/${NAME}"
						fi
					else
						TASK_ERROR=1
						TASK_ERROR_MSG="${NAME} is already installed"
						STATE="FAIL"
						continue
					fi
				fi

				if [ $FRZR_CHECK_UPDATE -eq 1 ]; then
					echo "Update available: ${NAME}"
				fi

				if [ $FRZR_STEAM_PROGRESS -eq 1 ]; then
					curl --http1.1 -# -L -o "${IMG_FILE}" -C - "${IMG_URL}" 2>&1 |
						stdbuf -oL tr '\r' '\n' | grep --line-buffered -oP '[0-9]*+(?=.[0-9])' | clean_progress 91 %
				elif [ -z ${SHOW_UI} ]; then
					echo "downloading ${NAME}..."
					curl --http1.1 -L -o "${IMG_FILE}" -C - "${IMG_URL}"
				else
					curl --http1.1 -# -L -o "${IMG_FILE}" -C - "${IMG_URL}" 2>&1 |
						stdbuf -oL tr '\r' '\n' | grep --line-buffered -oP '[0-9]*+(?=.[0-9])' | clean_progress 100 |
						whiptail --gauge "Downloading system image (${NAME})" 10 50 0
				fi
			fi
			echo "Entering Chucksum Case"
			STATE="CHECKSUM"
			;;
		"CHECKSUM")
			TASK_STATE="CHECKSUM"
			TASK_MSG="Verying checksums match"
			CHECKSUM2=$(sha256sum "${IMG_FILE}" | cut -d' ' -f 1)
			if [ "$CHECKSUM" != "$CHECKSUM2" ]; then
				rm -f "${IMG_FILE}"

				# We can attempt to redownload the image again here instead of aborting like the original behavior
				TASK_ERROR=1
				TASK_ERROR_MSG="Checksum does not match"
				STATE="FAIL"
				continue
			fi
			TASK_TRACKER=1 # Tell any listeners this task was completed, I'm not sure this variable will be needed in the end
			echo "Entering Extract Case"
			STATE="EXTRACT"
			;;
		"EXTRACT")
			TASK_STATE="EXTRACT"
			# Extract tar of system image
			# This step might not ever need to be used, but left here depending on the occasion it may be needed.

			# Write the deployment image to disk (if it was not being done already by the download step)
			if is_btrfs_subvolume "$SUBVOL"; then
				# skip this step: the subvolume has been created already
				STATE="INSTALL"
				continue
			fi

			# Use BTRFS receive to install the image
			if [ -z ${SHOW_UI} ]; then
				echo "Installing ${NAME}..."
			else
				# TODO: verify if this really works
				whiptail --infobox "Extracting and installing system image (${NAME}). This may take some time." 10 50
			fi

			local install_result=$(install_image "${IMG_FILE}" "${DEPLOY_PATH}")
			if echo "${install_result}" | grep -q 'ERROR'; then
				TASK_ERROR=1
				TASK_ERROR_MSG="Error extracting the deployment image: ${install_result}"
				STATE="FAIL"
			fi

			STATE="INSTALL"
			;;
		"INSTALL")
			TASK_STATE="INSTALL"
			
			# TODO: use correct (unrenamed) files
			local vmlinuz_name="vmlinuz-linux"
			local initramfs_name="initramfs-linux.img"

			# Migrations should be able to modify the new installed image: set ${SUBVOL} R/W
			#local set_subvol_rw=$(btrfs_subvolume_set_rw "${SUBVOL}")
			#if echo "${set_subvol_rw}" | grep -Fqx 'ERROR'; then
			#	TASK_ERROR=1
			#	TASK_ERROR_MSG="Cannot set ${SUBVOL} R/W: ${set_subvol_rw}"
			#	STATE="FAIL"
			#	continue
			#fi

			if [ -d "${SUBVOL}/efi" ]; then
				mount --bind "${EFI_MOUNT_PATH}" "${SUBVOL}/efi"
			else
				echo "TODO: missing /efi" # TODO: warn about missing /efi
			fi

			# Execute and migrations available in the image to be deployed
			# SKIPPING for now to prevent errors caused by conflicts with the systemd-migration hook in the images
			#execute_migrations "${NAME}" "${SUBVOL}" "${MOUNT_PATH}" # TODO: some old migrations are incompatible with the current model: use some newer migration scheme!

			# set that subvolume back to RO
			#local $pacman_subvol_set_ro_res=$(btrfs_subvolume_set_ro "${SUBVOL}/usr/var/lib/pacman")
			#if echo "${pacman_subvol_set_ro_res}" | grep -Fqx "ERROR"; then
			#	TASK_ERROR=1
			#	TASK_ERROR_MSG="Cannot set /usr/var/lib/pacman subvolume as read-only"
			#	STATE="FAIL"
			#	continue
			#fi

			STATE="VERIFY"
			;;
		"VERIFY")
			TASK_STATE="VERIFY"

			# verify the subvolume integrity
			TASK_MSG="Checking integrity of deployed image"
			if btrfs scrub start -Bdr "${SUBVOL}"; then
				# Verify the system installation status, check for device quirks, and prepare for cleanup
				# Check if the FIRMWARE_OVERRIDE variable is set by the install media, if so enable firmware overrides
				if [ -n "${FIRMWARE_OVERRIDE}" ]; then
					echo "export USE_FIRMWARE_OVERRIDES=1" >${MOUNT_PATH}/etc/device-quirks.conf
				fi

				# Run frzr-tweaks to execute the device-quirks to be supplied by the deployed images
				#frzr-tweaks # TODO: pass the root as an argument and in the script default to "/"

				# Run frzr-initramfs to create mkinicpio.conf and build an initramfs
				#frzr-initramfs # TODO: review, this writes mkinitcpio.conf, make sure it stays aligned with the image one
				echo "Entering Cleanup Case"
				STATE="CLEANUP"
			else
				TASK_ERROR=1
				TASK_ERROR_MSG="FS check on btrfs subvolume '$SUBVOL' failed: image integrity compromised"
				STATE="FAIL"
			fi
			;;
		"CLEANUP")
			TASK_STATE="CLEANUP"
			# Delete the downloaded system img etc.

			# delete deployments under these conditions:
			# - we are currently running inside a frzr deployment (i.e. not during install)
			# - the deployment is not currently running
			# - the deployment is not configured to be run on next boot
			if frzr-release >/dev/null; then
				CURRENT=$(frzr-release)
				local deployment_to_be_removed=$(get_deployment_to_delete ${CURRENT} ${BOOT_CFG} ${DEPLOY_PATH})

				if [ ! -z ${deployment_to_be_removed} ]; then
					echo "deleting ${deployment_to_be_removed}..."
					btrfs subvolume delete ${DEPLOY_PATH}/${deployment_to_be_removed} || true
					rm -rf "${EFI_MOUNT_PATH}/${deployment_to_be_removed}"
				fi
			fi

			# This is used to update the EFI partition: setting up systemd-boot (or whatever else bootlader might be supported) to boot the new deployment
			local efi_update_result=$(prepare_efi_partition "${NAME}" "${EFI_MOUNT_PATH}" ${SUBVOL} "${amd_ucode}" "${intel_ucode}" "${vmlinuz_name}" "${initramfs_name}" "${additional_arguments}" "${deploy_systemd_boot_cfg}")
			if echo "${efi_update_result}" | grep -q 'ERROR'; then
				# bootloader configuration could not be updated
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not update the EFI partition: ${efi_update_result}"
				STATE="FAIL"
				continue
			fi

			# Remove download artifacts (if any)
			rm -f ${MOUNT_PATH}/*.img.*

			rm -rf /var/lib/pacman # undo frzr-unlock

			TASK_MSG="Finding deployment subvolume ID..."
			local subvolid=$(btrfs_subvol_get_id "$SUBVOL")
			if echo "$subvolid" | grep -Fqx "ERROR"; then
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not find subvolume ID of the new deployment"
				STATE="FAIL"
				continue
			fi
			
			# Activates the new deployed image by making it the default btrfs subvolume
			# systemd-equipped initramfs images will automount the default subvolume as the rootfs
			TASK_MSG="Activating the new deployment (subvolid=${subvolid}) as the default subvolume..."
			if ! btrfs subvolume set-default "$subvolid" "${MOUNT_PATH}"; then
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not activate the new deployment"
				STATE="FAIL"
				continue
			fi

			STATE="SUCCESS"
			;;
		"SUCCESS")
			# This state should only be used if the installation completed without errors
			TASK_STATE="SUCCESS"

			# umount the efi path
			if mountpoint -q ${EFI_MOUNT_PATH}; then
				umount -l ${EFI_MOUNT_PATH}
			fi

			# umount the frzr_root subvolume
			if mountpoint -q ${MOUNT_PATH}; then
				umount -l ${MOUNT_PATH}
			fi

			TASK_MSG="Deployment is successful: reboot to boot into ${NAME}"

			RUNNING=false
			;;
		"FAIL")
			# This state should only be used if the installation failed
			
			# umount the efi path
			if mountpoint -q ${EFI_MOUNT_PATH}; then
				umount -l ${EFI_MOUNT_PATH}
			fi

			# umount the frzr_root subvolume
			if mountpoint -q ${MOUNT_PATH}; then
				umount -l ${MOUNT_PATH}
			fi
			
			TASK_STATE="FAIL"
			RUNNING=false
			;;
		*)
			TASK_STATE="UNKNOWN_ERROR"
			echo "Something went terribly wrong"
			RUNNING=false
			;;
		esac
	done
}

# Start the main() method like this for now since the old logic doesn't work
main "$@"

#if [ "$0" = "$BASH_SOURCE" ]; then
#	main "$@"
#fi
