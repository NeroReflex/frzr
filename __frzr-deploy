#! /bin/bash

# TODO: when the refactor is ready these won't be necessary, and will prevent proper output.
set -e
set -o pipefail

# Writes log output where it will be easy to fetch
# $1 the message to be written
# $2 (optional) severity: 1 for error, 2 for warning
write_log() {
	local msg=${1}
	local severity=${2}

	# TODO: make use of a parameter that is the location of the logfile
	# TODO: append [ERROR] or [WARNING] or [INFO] depending on the severity
	echo "$msg" | tee --append /tmp/frzr-deploy.log
}

# get the image url for the given channel
# $1 channel (can be either "stable", "testing" or "unstable")
# stdout the image url
get_img_url() {
	local update_channel=${1}

	# Order by creation date in reverse
	result=$(jq 'sort_by(.created_at) | reverse')

	# Remove entries which have not been completed uploading
	result=$(echo "${result}" | jq 'del(.[] | select(.assets[].state != "uploaded"))')

	# Always check for stable date
	if stable_release_date=$(echo "${result}" | jq -er '[ .[] |
			select(.prerelease==false) ] |
			first |
			.created_at'
		); then
		# Check for stable url, this is the latest that have prerelease == false
		stable_download_url=$(echo "${result}" | jq -r '[ .[] |
			select(.prerelease==false) ] |
			first |
			.assets[] |
			select(.browser_download_url | test("img")) |
			.browser_download_url'
		)
	else
		# No stable channel found, pick some (old) values
		# For testing/ channel selection
		stable_release_date="1970-01-01T00:00:00Z"
		stable_download_url=""
	fi


	# Filter channels by release naming conventions
	if [[ "$update_channel" =~ ^[0-9]+\-?[0-9]*$ ]] ; then
		# Check first for explicit version numbers between stable releases
		# Useful for downgrading
		result=$(echo "${result}" | jq -r "[ .[] |
					select(.prerelease==false) |
					select(.name|test(\" ${update_channel}\$\")) ] |
					first |
					.assets[] |
					select(.browser_download_url | test(\"img\")) |
					.browser_download_url"
				)
	elif [ "$update_channel" == "stable" ]; then
		result=$stable_download_url
	elif [ "$update_channel" == "testing" ]; then
		# Testing channel have prerelease = true and no other tags
		if testing_release_date=$(echo "${result}" | jq -er '[ .[] |
			select(.prerelease==true) |
			select(.name|test("\\[.*\\]")|not) ] |
			first |
			.created_at'
			); then
			testing_url=$(echo "${result}" | jq -r '[ .[] |
						select(.prerelease==true) |
						select(.name|test("\\[.*\\]")|not) ] |
						first |
						.assets[] |
						select(.browser_download_url | test("img")) |
						.browser_download_url'
					)
			if [ $(date -d $testing_release_date +%s) -le $(date -d $stable_release_date +%s) ]; then
				result=$stable_download_url
			else
				result=$testing_url
			fi
		else
			result=$stable_download_url
		fi
	else
		# Match any release with CHANNEL as a tag (including unstable)
		result=$(echo ${result} | jq "[ .[] | select(.prerelease==true) | select(.name|test(\"\\\[${update_channel}\\\]\" ; \"i\")) ]")
			if unstable_release_date=$(echo "${result}" | jq -er "[ .[] |
					select(.prerelease==true) |
					select(.name|test(\"\\\[${update_channel}\\\]\" ; \"i\")) ] |
					first |
					.created_at"
				); then
			unstable_url=$(echo "${result}" | jq -r "[ .[] |
						select(.prerelease==true) |
						select(.name|test(\"\\\[${update_channel}\\\]\" ; \"i\")) ] |
						first |
						.assets[] |
						select(.browser_download_url | test(\"img\")) |
						.browser_download_url"
					)
			if [ $(date -d $unstable_release_date +%s) -le $(date -d $stable_release_date +%s) ]; then
				result=$stable_download_url
			else
				result=$unstable_url
			fi
		else
			result=$stable_download_url
		fi
	fi

	echo $result
}

# Write the systemd-boot entry needed to boot the specified deployment
# Note: this function can ignore amd-ucode and intel-ucode if those are not found since mkinitcpio will place those
# in the initramfs and including them on systemd-boot is not deprecated.
# $1 the deployment version; this is also the deployment name (the name of the subvolume to be used as rootfs)
# $2 /boot mount path
# $3 amd_ucode.img path relative to $2/$3/ (mind not inserting an initial /)
# $4 intel_ucode.img path relative to $2/$3/ (mind not inserting an initial /)
# $5 vmlinuz-linux path relative to $2/$3/ (mind not inserting an initial /)
# $6 initramfs-linux.img path relative to $2/$3/ (mind not inserting an initial /)
# $7 additional arguments to be used in the kernel cmdline
# $8 entry config file name (mind not inserting an initial /)
# stdout the configuration to be written to a systemd-boot entry to make the given deployment version bootable
# return "OK" for success, and error string otherwise"
generate_systemd_boot_cfg() {
	local version=${1}
	local mount_path=${2}
	local amd_ucode=${3}
	local intel_ucode=${4}
	local vmlinuz=${5}
	local initramfs=${6}
	local additional_arguments=${7}
	local boot_entry=${8}

	local entry_conf="$mount_path/loader/entries/${boot_entry}"

	# search for the actual kernel to boot
	if [ -f ${mount_path}/${version}/${vmlinuz} ]; then
		# search fot the initramfs
		if [ -f ${mount_path}/${version}/${initramfs} ]; then
			# write title chimeraos-46_fcc653a3 (also creating the boot entry file if it doesn't exists yet)
			echo "title ${version}" | tee ${entry_conf} >/dev/null
			
			# write linux /chimeraos-46_fcc653a3/vmlinuz-linux
			echo "linux /${version}/${vmlinuz}" | tee --append ${entry_conf} >/dev/null

			# write /chimeraos-46_fcc653a3/amd-ucode.img if necessary
			if [ -f ${mount_path}/${version}/${amd_ucode} ]; then
				write_log "$FUNCNAME: The AMD ucode has been found at '$mount_path/$version/$amd_ucode' -- amd-ucode included in boot configuration"
				echo "initrd /${version}/${amd_ucode}" | tee --append ${entry_conf} >/dev/null
			else
				echo "# amd-ucode.img omitted" | tee --append ${entry_conf} >/dev/null
				write_log "$FUNCNAME: The AMD ucode has NOT been found at '$mount_path/$version/$amd_ucode' -- amd-ucode initrd omitted from boot configuration"
			fi

			# write /chimeraos-46_fcc653a3/intel-ucode.img if necessary
			if [ -f ${mount_path}/${version}/${intel_ucode} ]; then
				write_log "$FUNCNAME: Intel ucode has been found at '$mount_path/$version/$intel_ucode' -- intel-ucode included in boot configuration"
				echo "initrd /${version}/${intel_ucode}" | tee --append ${entry_conf} >/dev/null
			else
				echo "# intel-ucode.img omitted" | tee --append ${entry_conf} >/dev/null
				write_log "$FUNCNAME: Intel ucode has NOT been found at '$mount_path/$version/$intel_ucode' -- intel-ucode initrd omitted from boot configuration" | tee --append ${entry_conf} >/dev/null
			fi

			# write /chimeraos-46_fcc653a3/initrams-linuz.img
			echo "initrd /${version}/${initramfs}" | tee --append ${entry_conf} >/dev/null

			# write kernel cmdline
			echo "options root=LABEL=frzr_root rw rootflags=subvol=deployments/${version} quiet splash loglevel=3 rd.systemd.show_status=auto rd.udev.log_priority=3 ${additional_arguments}" | tee --append ${entry_conf} >/dev/null

			# return success
			echo "OK"
		else
			write_log "$FUNCNAME: initramfs has NOT been found at '$mount_path/$version/$initramfs'" 1
			
			# return the error to be printed out
			echo "ERROR: initramfs not found"
		fi
	else
		write_log "$FUNCNAME: vmlinuz (linux kernel) has been found at '$mount_path/$version/$vmlinuz'" 1
		
		# return the error to be printed out
		echo "ERROR: kernel not found"
	fi
}

get_deployment_to_delete() {
	local current_version=${1}
	local boot_cfg_path=${2}
	local deployment_path=${3}

	local TO_BOOT=`get_next_boot_deployment ${current_version} ${boot_cfg_path}`

	ls -1 ${deployment_path} | grep -v ${current_version} | grep -v ${TO_BOOT} | head -1 || echo
}

get_next_boot_deployment() {
	local current_version=${1}
	local boot_cfg_path=${2}

	local TO_BOOT='this-is-not-a-valid-version-string'
	if [ -f "${boot_cfg_path}" ] && grep "^title" "${boot_cfg_path}" > /dev/null; then
		TO_BOOT=`grep ^title ${boot_cfg_path} | sed 's/title //'`
	fi

	echo ${TO_BOOT}
}

clean_progress() {
	local scale=$1
	local postfix=$2
	local last_value=$scale
	while IFS= read -r line; do
		value=$(( ${line}*${scale}/100 ))
		if [ "$last_value" != "$value" ]; then
			echo ${value}${postfix}
			last_value=$value
		fi
	done
}

# Check that the system has been boot with UEFI
# stdout "OK" on success, an error otherwise
check_uefi() {
	if [ -d /sys/firmware/efi/efivars ]; then
		echo "OK"
	else
		write_log "$FUNCNAME: Legacy BIOS installs are not supported" 1
		echo "ERROR: Not a UEFI system"
	fi
}

# Check if there are migrations available in the image to be deployed and run them one by one
# Note: migrations are functions named post_install inside (executable) files with .migration extension
# stored inside $2/usr/lib/frzr.d/
#
# $1 the deployment version; this is also the deployment name (the name of the subvolume to be used as rootfs)
# $2 the deployment mounted subvolume: while migrations are run this has to be read-write
# $3 frzr_root the mounted path to the main btrfs subvolume (the one that contains home as a subvolume)
# stdout "OK" on success, the error otherwise
execute_migrations() {
	local version=$1
	local deployment=$2
	local frzr_root=$3

	if compgen -G "${deployment}"/usr/lib/frzr.d/*.migration > /dev/null ; then
		for m in "${deployment}"/usr/lib/frzr.d/*.migration ;
		do
			unset -f post_install
			. $m
			if [ "$(type -t post_install)" == function ] ; then
				post_install "${frzr_root}" "${deployment}" "${version}"
			fi
			unset -f post_install
		done
	fi
}

# Write the systemd-boot entry needed to boot the specified deployment
# Note: this function can ignore amd-ucode and intel-ucode if those are not found since mkinitcpio will place those
# in the initramfs and including them on systemd-boot is not deprecated.
# $1 the deployment version; this is also the deployment name (the name of the subvolume to be used as rootfs)
# $2 /boot mount path
# $3 amd_ucode.img path relative to $2/$3/ (mind not inserting an initial /)
# $4 intel_ucode.img path relative to $2/$3/ (mind not inserting an initial /)
# $5 vmlinuz-linux path relative to $2/$3/ (mind not inserting an initial /)
# $6 initramfs-linux.img path relative to $2/$3/ (mind not inserting an initial /)
# $7 additional arguments to be used in the kernel cmdline
# $8 entry config file name (mind not inserting an initial /)
# stdout the configuration to be written to a systemd-boot entry to make the given deployment version bootable
# return "OK" for success, and error string otherwise"
prepare_efi_partition() {
	local version=${1}
	local mount_path=${2}
	local amd_ucode=${3}
	local intel_ucode=${4}
	local vmlinuz_name=${5}
	local initramfs_name=${6}
	local additional_arguments=${7}
	local boot_entry=${8}

	local systemd_boot_update_result=$(generate_systemd_boot_cfg "${version}" "${mount_path}" "${amd_ucode}" "${intel_ucode}" "${vmlinuz_name}" "${initramfs_name}" "${additional_arguments}" "${boot_entry}")
	echo "systemd-boot install: ${systemd_boot_update_result}"

	if echo "${systemd_boot_update_result}" | grep -q 'OK'; then
		echo "default ${boot_entry}" > ${mount_path}/loader/loader.conf

		echo "OK"
	else
		echo "${systemd_boot_update_result}"
	fi
}

main() {
	if [ $EUID -ne 0 ]; then
		echo "$FUNCNAME: $(basename $0) not run as root"
		exit 1
	fi

	FRZR_CHECK_UPDATE=0
	FRZR_STEAM_PROGRESS=0
	FRZR_SOURCE=""
	FRZR_PARAMS=""

	while (( "$#" )); do
		case $1 in
			--check)
				FRZR_CHECK_UPDATE=1
				shift
				;;
			--steam-progress)
				FRZR_STEAM_PROGRESS=1
				shift
				;;
			-*|--*)
				echo "Unknown argument $1"
				exit 1
				;;
			*) # preserve positional arguments
				FRZR_PARAMS="${FRZR_PARAMS}$1 " # Use trailing space for the match below
				shift
				;;
		esac
	done

	check_uefi_result=$(check_uefi)
	echo "UEFI Check: ${check_uefi_result}"
	if echo "${check_uefi_result}" | grep -q 'OK'; then
		# keep only the first param as source
		FRZR_SOURCE="${FRZR_PARAMS%% *}"

		MOUNT_PATH=/frzr_root

		if ! mountpoint -q ${MOUNT_PATH}; then
			MOUNT_PATH=/tmp/frzr_root
		fi

		if ! mountpoint -q ${MOUNT_PATH}; then
			mkdir -p ${MOUNT_PATH}
			mount -L frzr_root ${MOUNT_PATH}
			sleep 5
		fi

		if ! mountpoint -q ${MOUNT_PATH}/boot && ls -1 /dev/disk/by-label | grep frzr_efi > /dev/null; then
			mkdir -p ${MOUNT_PATH}/boot
			mount -L frzr_efi ${MOUNT_PATH}/boot
			sleep 5
		fi

		write_log "Using '${MOUNT_PATH}' as the main subvolume mount path"

		DEPLOY_PATH=${MOUNT_PATH}/deployments
		mkdir -p ${DEPLOY_PATH}

		# TODO: check that DEPLOY_PATH exists, and if not terminate the whole procedure giving the user an error

		write_log "Using '${DEPLOY_PATH}' as the deployment destination path"

		local deploy_systemd_boot_cfg="frzr.conf"

		BOOT_CFG="${MOUNT_PATH}/boot/loader/entries/${deploy_systemd_boot_cfg}"
		mkdir -p ${MOUNT_PATH}/boot/loader/entries

		# delete deployments under these conditions:
		# - we are currently running inside a frzr deployment (i.e. not during install)
		# - the deployment is not currently running
		# - the deployment is not configured to be run on next boot
		if frzr-release > /dev/null; then
			CURRENT=`frzr-release`
			local deployment_to_be_removed=`get_deployment_to_delete ${CURRENT} ${BOOT_CFG} ${DEPLOY_PATH}`

			if [ ! -z ${deployment_to_be_removed} ]; then
				echo "deleting ${deployment_to_be_removed}..."
				btrfs subvolume delete ${DEPLOY_PATH}/${deployment_to_be_removed} || true
				rm -rf ${MOUNT_PATH}/boot/${deployment_to_be_removed}
			fi
		fi

		if [ ! -z "$FRZR_SOURCE" ] && [ "$FRZR_SOURCE" != " " ] && [ $FRZR_CHECK_UPDATE -eq 0 ] && [ $FRZR_STEAM_PROGRESS -eq 0 ]; then
			echo "$FRZR_SOURCE" > "${MOUNT_PATH}/source"
		fi

		if [ -e "${MOUNT_PATH}/source" ]; then
			SOURCE=`cat "${MOUNT_PATH}/source" | head -1`
		else
			echo "WARNING: source wasn't specified"
		fi

		if [ "${local_install}" == true ]; then
				mkdir tmp_source
				mount -o rw -L FRZR_UPDATE /root/tmp_source
			FILE_NAME=$(basename /root/tmp_source/*.img.tar.xz*)
			NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
			SUBVOL="${DEPLOY_PATH}/${NAME}"
			IMG_FILE="/root/tmp_source/${FILE_NAME}"
		elif [[ "$FRZR_SOURCE" == *".img.tar.xz" ]]; then
			FILE_NAME=$(basename ${FRZR_SOURCE})
			NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
			SUBVOL="${DEPLOY_PATH}/${NAME}"
			IMG_FILE=${FRZR_SOURCE}
		elif [[ "$FRZR_SOURCE" == *".img" ]]; then
			FILE_NAME=$(basename ${FRZR_SOURCE})
			NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
			SUBVOL="${DEPLOY_PATH}/${NAME}"
			IMG_FILE=${FRZR_SOURCE}
		else
			REPO=$(echo "${SOURCE}" | cut -f 1 -d ':')
			CHANNEL=$(echo "${SOURCE}" | cut -f 2 -d ':')

			RELEASES_URL="https://api.github.com/repos/${REPO}/releases"

			IMG_URL=$(curl --http1.1 -L -s "${RELEASES_URL}" | get_img_url "${CHANNEL}")

			if [ -z "$IMG_URL" ] || [ "$IMG_URL" == "null" ]; then
				echo "No matching source found"
				if curl --http1.1 -L -s "${RELEASES_URL}" | grep "rate limit" > /dev/null; then
					echo "GitHub API rate limit exceeded"
					exit 29
				fi
				exit 1
			fi

			FILE_NAME=$(basename ${IMG_URL})
			NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
			BASE_URL=$(dirname "${IMG_URL}")
			CHECKSUM=$(curl --http1.1 -L -s "${BASE_URL}/sha256sum.txt" | cut -f -1 -d ' ')
			SUBVOL="${DEPLOY_PATH}/${NAME}"
			IMG_FILE="${MOUNT_PATH}/${FILE_NAME}"

			if [ -e ${SUBVOL} ]; then
				echo "${NAME} already installed; aborting"
				exit 7 # let Steam know there is no update available
			fi

			if [ $FRZR_CHECK_UPDATE -eq 1 ]; then
				echo "Update available: ${NAME}"
				exit 0 # let Steam know there is an update available
			fi

			if [ $FRZR_STEAM_PROGRESS -eq 1 ]; then
				curl --http1.1 -# -L -o "${IMG_FILE}" -C - "${IMG_URL}" 2>&1 | \
				stdbuf -oL tr '\r' '\n' | grep --line-buffered -oP '[0-9]*+(?=.[0-9])' | clean_progress 91 %
			elif [ -z ${SHOW_UI} ]; then
				echo "downloading ${NAME}..."
				curl --http1.1 -L -o "${IMG_FILE}" -C - "${IMG_URL}"
			else
				curl --http1.1 -# -L -o "${IMG_FILE}" -C - "${IMG_URL}" 2>&1 | \
				stdbuf -oL tr '\r' '\n' | grep --line-buffered -oP '[0-9]*+(?=.[0-9])' | clean_progress 100 | \
				whiptail --gauge "Downloading system image (${NAME})" 10 50 0
			fi

			CHECKSUM2=`sha256sum "${IMG_FILE}" | cut -d' ' -f 1`
			if [ "$CHECKSUM" != "$CHECKSUM2" ]; then
				rm -f "${IMG_FILE}"
				echo "checksum does not match; aborting"
				exit 1
			fi
		fi

		if [ -z ${SHOW_UI} ]; then
			echo "installing ${NAME}..."
		else
			whiptail --infobox "Extracting and installing system image (${NAME}). This may take some time." 10 50
		fi

		# TODO: see the additional image types branch and put this on a function of its own
		if [[ "${IMG_FILE##*.}" == "img" ]]; then
			btrfs receive --quiet ${DEPLOY_PATH} < ${IMG_FILE}
		else
			tar xfO ${IMG_FILE} | btrfs receive --quiet ${DEPLOY_PATH}
		fi

		local vmlinuz_name="vmlinuz-linux"
		local initramfs_name="initramfs-linux.img"

		# this is the place where the EFI partition is mounted during the deployment procedure
		local efi_root_path="${MOUNT_PATH}/boot"
		
		# each deployment will need its own kernel as well as initramfs to boot: place them in a EFI subdirectory
		mkdir -p ${efi_root_path}/${NAME}

		# Following steps copy kernel, initramfs and ucode to the EFI partition to be used on the next boot
		# TODO: move them in a function, and execute them after regenerating the initramfs and apply device-quirks
		# TODO: bonus point if these are run AFTER setting the deployment volume back in read-only state
		cp ${SUBVOL}/boot/vmlinuz-linux ${efi_root_path}/${NAME}/${vmlinuz_name}
		cp ${SUBVOL}/boot/initramfs-linux.img ${efi_root_path}/${NAME}/${initramfs_name}

		local amd_ucode="amd-ucode.img"
		if [ -e ${SUBVOL}/boot/amd-ucode.img ] ; then
			cp ${SUBVOL}/boot/amd-ucode.img ${efi_root_path}/${NAME}/${amd_ucode}
		fi

		local intel_ucode="intel-ucode.img"
		if [ -e ${SUBVOL}/boot/intel-ucode.img ] ; then
			cp ${SUBVOL}/boot/intel-ucode.img ${efi_root_path}/${NAME}/${intel_ucode}
		fi

		local additional_arguments=""
		if [ -f ${SUBVOL}/usr/lib/frzr.d/bootconfig.conf ] ; then
			additional_arguments="$additional_arguments $(cat ${SUBVOL}/usr/lib/frzr.d/bootconfig.conf)"
		else
			write_log "$FUNCNAME: File '${SUBVOL}/usr/lib/frzr.d/bootconfig.conf' has not been found" 2
		fi

		# TODO: migrations should be able to modify the new installed image: set ${SUBVOL} R/W

		# Execute and migrations available in the image to be deployed
		execute_migrations "${NAME}" "${SUBVOL}" "${MOUNT_PATH}"

		# Export variables to be used by child processes for frzr-tweaks and frzr-initramfs
		export MOUNT_PATH
		export SUBVOL
		export NAME
		# TODO: remove the above when said tools can accept parameters

		# Check if the FIRMWARE_OVERRIDE variable is set by the install media, if so enable firmware overrides
		if [ -n "${FIRMWARE_OVERRIDE}" ]; then
			echo "export USE_FIRMWARE_OVERRIDES=1" > ${MOUNT_PATH}/etc/device-quirks.conf
		fi

		# Run frzr-tweaks to execute the device-quirks to be supplied by the deployed images
		frzr-tweaks # TODO: pass the root as an argument and in the script default to "/"

		# Run frzr-initramfs to create mkinicpio.conf and build an initramfs
		frzr-initramfs # TODO: review, this writes mkinitcpio.conf, make sure it stays aligned with the image one

		# TODO: migrations have been executed, frzr-tweaks and frzr-initramfs have been run: set the deployment subvolume back to being R/O


		# This is used to update the EFI partition: setting up systemd-boot (or whatever else bootlader might be supported) to boot the new deployment
		local efi_update_result=$(prepare_efi_partition "${NAME}" "${efi_root_path}" "${amd_ucode}" "${intel_ucode}" "${vmlinuz_name}" "${initramfs_name}" "${additional_arguments}" "${deploy_systemd_boot_cfg}")
		echo "EFI update: ${efi_update_result}"
		if echo "${efi_update_result}" | grep -q 'OK'; then
			rm -f ${MOUNT_PATH}/*.img.*

			rm -rf /var/lib/pacman # undo frzr-unlock

			echo "deployment complete; restart to boot into ${NAME}"

			umount -R -l ${MOUNT_PATH} # TODO: move this in frzr-deploy and umount without -l -R MOUNT_PATH if it was not mounted when the update started
		else
			echo "deployment failed; could not update the EFI partition"
			exit 1
		fi
	else # No UEFI found
		echo "deployment failed; system not booted with UEFI: disable MBR (or CSM) boot in your motherboard setup"
		exit 1
	fi 
}

if [ "$0" = "$BASH_SOURCE" ] ; then
	main "$@"
fi
