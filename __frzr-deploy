#! /bin/bash

set -o pipefail

# import methods
#source "${BASH_SOURCE%/*}/__frzr" "$@"

frzr_deploy() {
	#TODO Utilize the state machine to manage the individual proccesses to send signals to external monitors
	## Signals
	#TASK_STATE="" # The current state of the state machine
	#TASK_MSG="" # TASK_MSG will be read by external tools. EX TASK_MSG="Preparing user directory"
	#TASK_TRACKER=0 # TASK_TRACKER will be used to signal back that the current TASK_MSG in queue is handled or not 0 = Pending 1 = Completed
	#TASK_ERROR=0 # Signal to let listeners know that the task had an error.
	#TASK_ERROR_MSG="" # Error message. EX: "Unexpected I/O errors found during write"
	#TASK_WARNING=0 # Signal to let listeners know there is a warning
	#TASK_WARNING_MSG="" # Warning message. EX: "BTRFS filesystem was supposed to be locked, but it was already unlocked. Continuing.."

	FRZR_CHECK_UPDATE=0
	FRZR_STEAM_PROGRESS=0
	FRZR_SOURCE=""
	FRZR_PARAMS=""

	local MOUNTED_MOUNT_PATH="no"
	local MOUNTED_EFI_MOUNT_PATH="no"

	local RUNNING=true
	STATE="FRZR_DEPLOY_CHECK"
	while $RUNNING; do
		case "$STATE" in
		"FRZR_DEPLOY_CHECK")
			TASK_STATE="CHECK"
			TASK_MSG="Checking for root privileges"
			if [ $EUID -ne 0 ]; then
				TASK_ERROR=1
				TASK_ERROR_MSG="$(basename $0) not run as root"
				STATE="FAIL"
				continue
			fi

			TASK_MSG="Checking is system has booted via UEFI"
			check_uefi_result=$(check_uefi)
			if echo "${check_uefi_result}" | grep -Fqx 'ERROR'; then
				TASK_ERROR=1
				TASK_ERROR_MSG="UEFI boot check failed: ${check_uefi_result}"
				STATE="FAIL"
				continue
			fi
			
			# Check if any updates are available and preserve FRZR parameters
			while (("$#")); do
				case $1 in
				--check)
					FRZR_CHECK_UPDATE=1
					shift
					;;
				--steam-progress)
					FRZR_STEAM_PROGRESS=1
					shift
					;;
				-* | --*)
					TASK_ERROR=1
					TASK_ERROR_MSG="Unknown argument $1"
					STATE="FAIL"
					;;
				*)                               # preserve positional arguments
					FRZR_PARAMS="${FRZR_PARAMS}$1 " # Use trailing space for the match below
					shift
					;;
				esac
			done

			# keep only the first param as source
			FRZR_SOURCE="${FRZR_PARAMS%% *}"
			if frzr-release > /dev/null; then
				CURRENT=`frzr-release`
			fi

			STATE="BEGIN"
			;;
		"BEGIN")
			TASK_STATE="BEGIN"
			
			MOUNT_PATH="/frzr_root"

			# Make sure the frzr_root is mounted during the deployment procedure
			# this code is based on the fact that when a btrfs filesystem is created
			# the default subvolid that is created contextually has the ID set to 256
			# also as a matter of fact in btrfs is impossible to change subvolumes IDs
			if ! mountpoint -q "${MOUNT_PATH}" && ls -1 /dev/disk/by-label | grep frzr_root > /dev/null; then
				MOUNT_PATH="/tmp/frzr_root"
				TASK_MSG="Preparing '${MOUNT_PATH}' to be used as the main subvolume mount path"
				mkdir -p ${MOUNT_PATH}
				if mount -L frzr_root -t btrfs -o subvolid=5,rw "${MOUNT_PATH}"; then
					MOUNTED_MOUNT_PATH="yes"
				fi
				sleep 5
			fi

			if mountpoint -q "${MOUNT_PATH}" && ls -1 /dev/disk/by-label | grep frzr_root > /dev/null; then
				DEPLOY_PATH="${MOUNT_PATH}/deployments"
				
				TASK_MSG="Preparing '${DEPLOY_PATH}' to be used as the deployment destination path"

				# Make sure DEPLOY_PATH exists
				mkdir -p "${DEPLOY_PATH}"
				if [ ! -d "${DEPLOY_PATH}" ]; then
					TASK_ERROR=1
					TASK_ERROR_MSG="Could not create ${DEPLOY_PATH} to to store deployments"
					STATE="FAIL"
					continue
				fi

				# Make sure the EFI partition is mounted during the deployment procedure
				EFI_MOUNT_PATH="${MOUNT_PATH}/efi"

				TASK_MSG="Preparing '${EFI_MOUNT_PATH}' to be used as the EFI System path"

				if ! mountpoint -q "${EFI_MOUNT_PATH}" && ls -1 /dev/disk/by-label | grep frzr_efi >/dev/null; then
					mkdir -p "${EFI_MOUNT_PATH}"
					if mount -L frzr_efi "${EFI_MOUNT_PATH}"; then
						MOUNTED_EFI_MOUNT_PATH="yes"
					fi
					sleep 5
				fi

				# Check the "EFI System" partition is actually mounted
				if mountpoint -q "${EFI_MOUNT_PATH}" && ls -1 /dev/disk/by-label | grep frzr_efi >/dev/null; then
					STATE="PREPARE"
				else
					TASK_ERROR=1
					TASK_ERROR_MSG="Could not bind ${EFI_MOUNT_PATH} to frzr_efi (boot) partition"
					STATE="FAIL"
				fi
			else
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not bind ${MOUNT_PATH} to frzr_root main subvolume"
				STATE="FAIL"
			fi
			;;
		"PREPARE")
			TASK_STATE="PREPARE"

			# Before the new image is deployed
			# delete old deployments under these conditions:
			# - the current deployment is known
			# - the deployment is not currently running
			if echo "${CURRENT}" | grep -Fqx 'ERROR'; then
				TASK_WARNING=1
				TASK_WARNING_MSG="Could not retrieve deployment to keep: ${CURRENT}"
			else
				for deployment_to_be_removed in "${DEPLOY_PATH}"/*; do
					if [ ! -z "${deployment_to_be_removed}" ] && [ -d "${deployment_to_be_removed}" ]; then
						if is_btrfs_subvolume "${deployment_to_be_removed}"; then
							local removal_deployment=$(basename "${deployment_to_be_removed}")

							if echo "${removal_deployment}" | grep -Fqx "${CURRENT}"; then
								echo "Deployment will be kept: ${removal_deployment}"
							else
								TASK_MSG="Deleting deployment ${removal_deployment}: it is not the current '${CURRENT}'"
								echo "$TASK_MSG"

								# Delete deployment boot files taking up space in /efi 
								if [ -d "${EFI_MOUNT_PATH}/${removal_deployment}" ]; then
									TASK_MSG="deleting deployment boot files from '${EFI_MOUNT_PATH}/${removal_deployment}'"
									echo "Doing rm -rf ${EFI_MOUNT_PATH}/${removal_deployment}"
									rm -rf "${EFI_MOUNT_PATH}/${removal_deployment}"
									echo "Done rm -rf"
								fi
								
								# Delete deployment entries (this code is based on the fact that names of entries are generated as they are in prepare_efi_partition)
								for entry_path in "${EFI_MOUNT_PATH}"/loader/entries/*.conf; do
									if echo "${entry_path}" | grep -Fqx "${removal_deployment}"; then
										TASK_MSG="deleting deployment boot entry '${entry_path}'"
										echo "Doing rm -rf ${entry_path}"
										rm -f "${entry_path}"
									fi
								done

								# Execute deployment removal scripts
								TASK_MSG="Executing removal hooks"
								local deployment_removal_hooks=$(execute_removal "${removal_deployment}" "${deployment_to_be_removed}" "${MOUNT_PATH}")
								if echo "${deployment_removal_hooks}" | grep -Fqx "ERROR"; then
									TASK_ERROR=1
									TASK_ERROR_MSG="Removal hook on subvolume '${deployment_to_be_removed}' failed: ${deployment_removal_hooks}"
									STATE="FAIL"
									continue
								fi

								# Delete the deployment btrfs subvolume
								local deployment_removal_result=$(btrfs_subvolume_simple_delete "${DEPLOY_PATH}/${removal_deployment}")
								if echo "${deployment_removal_result}" | grep -Fqx "ERROR"; then
									TASK_ERROR=1
									TASK_ERROR_MSG="Could not delete the old deployment '${removal_deployment}'"
									STATE="FAIL"
									continue
								fi
							fi
						fi
					fi
				done
			fi

			STATE="DOWNLOAD"
			;;
		"DOWNLOAD")
			TASK_STATE="DOWNLOAD"
			# Check if source needs updated or needs to be created for the first time
			if [ ! -z "$FRZR_SOURCE" ] && [ "$FRZR_SOURCE" != " " ] && [ $FRZR_CHECK_UPDATE -eq 0 ] && [ $FRZR_STEAM_PROGRESS -eq 0 ]; then
				echo "$FRZR_SOURCE" >"${MOUNT_PATH}/source"
			fi

			if [ -e "${MOUNT_PATH}/source" ]; then
				SOURCE=$(cat "${MOUNT_PATH}/source" | head -1)
			else
				echo "WARNING: source wasn't specified"
			fi

			if [ "${local_install}" == true ]; then
				mkdir tmp_source
				mount -o rw -L FRZR_UPDATE /root/tmp_source
				FILE_NAME=$(basename /root/tmp_source/*.img.tar.xz*)
				NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
				SUBVOL="${DEPLOY_PATH}/${NAME}"
				IMG_FILE="/root/tmp_source/${FILE_NAME}"
			elif [[ "$FRZR_SOURCE" == *".img.tar.xz" ]]; then
				FILE_NAME=$(basename ${FRZR_SOURCE})
				NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
				SUBVOL="${DEPLOY_PATH}/${NAME}"
				IMG_FILE="${FRZR_SOURCE}"
			elif [[ "$FRZR_SOURCE" == *".img" ]]; then
				FILE_NAME=$(basename ${FRZR_SOURCE})
				NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
				SUBVOL="${DEPLOY_PATH}/${NAME}"
				IMG_FILE="${FRZR_SOURCE}"
			else
				REPO=$(echo "${SOURCE}" | cut -f 1 -d ':')
				CHANNEL=$(echo "${SOURCE}" | cut -f 2 -d ':')

				RELEASES_URL="https://api.github.com/repos/${REPO}/releases"

				IMG_URL=$(curl --http1.1 -L -s "${RELEASES_URL}" | get_img_url "${CHANNEL}")

				if [ -z "$IMG_URL" ] || [ "$IMG_URL" == "null" ]; then
					if curl --http1.1 -L -s "${RELEASES_URL}" | grep "rate limit" >/dev/null; then
						TASK_ERROR=1
						TASK_ERROR_MSG="GitHub API rate limit exceeded"
						STATE="FAIL"
					else
						TASK_ERROR=1
						TASK_ERROR_MSG="No matching source found"
						STATE="FAIL"
					fi

					continue
				fi

				FILE_NAME=$(basename ${IMG_URL})
				NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
				BASE_URL=$(dirname "${IMG_URL}")
				EXPECTED_CHECKSUM=$(curl --http1.1 -L -s "${BASE_URL}/sha256sum.txt" | cut -f -1 -d ' ')
				SUBVOL="${DEPLOY_PATH}/${NAME}"
				IMG_FILE="${MOUNT_PATH}/${FILE_NAME}"

				if [ -e "${SUBVOL}" ]; then
					# Only allow deleting the subvolume if we are booted in the installer.
					if [ "$UPGRADE" -eq 0 ]; then
						MSG="${NAME} is already installed, would you like to delete this and re-deploy?"
						if (whiptail --yesno "${MSG}" 10 50); then
							echo "deleting ${NAME}"
							btrfs subvolume delete "${SUBVOL}"
							rm -rf "${EFI_MOUNT_PATH}/${NAME}"
						fi
					else
						TASK_ERROR=1
						TASK_ERROR_MSG="${NAME} is already installed"
						STATE="FAIL"
						continue
					fi
				fi

				if [ $FRZR_CHECK_UPDATE -eq 1 ]; then
					echo "Update available: ${NAME}"
				fi

				if [ $FRZR_STEAM_PROGRESS -eq 1 ]; then
					curl --http1.1 -# -L -o "${IMG_FILE}" -C - "${IMG_URL}" 2>&1 |
						stdbuf -oL tr '\r' '\n' | grep --line-buffered -oP '[0-9]*+(?=.[0-9])' | clean_progress 91 %
				elif [ -z ${SHOW_UI} ]; then
					echo "downloading ${NAME}"
					curl --http1.1 -L -o "${IMG_FILE}" -C - "${IMG_URL}"
				else
					curl --http1.1 -# -L -o "${IMG_FILE}" -C - "${IMG_URL}" 2>&1 |
						stdbuf -oL tr '\r' '\n' | grep --line-buffered -oP '[0-9]*+(?=.[0-9])' | clean_progress 100 |
						whiptail --gauge "Downloading system image (${NAME})" 10 50 0
				fi
			fi
			echo "Entering Chucksum Case"
			STATE="CHECKSUM"
			;;
		"CHECKSUM")
			TASK_STATE="CHECKSUM"
			TASK_MSG="Verying checksums match"
			ACTUAL_CHECKSUM=$(sha256sum "${IMG_FILE}" | cut -d' ' -f 1)
			if [ "$EXPECTED_CHECKSUM" != "$ACTUAL_CHECKSUM" ]; then
				rm -f "${IMG_FILE}"

				# We can attempt to redownload the image again here instead of aborting like the original behavior
				TASK_ERROR=1
				TASK_ERROR_MSG="Checksum does not match"
				STATE="FAIL"
				continue
			fi
			TASK_TRACKER=1 # Tell any listeners this task was completed, I'm not sure this variable will be needed in the end
			echo "Entering Extract Case"
			STATE="EXTRACT"
			;;
		"EXTRACT")
			TASK_STATE="EXTRACT"
			# Extract tar of system image
			# This step might not ever need to be used, but left here depending on the occasion it may be needed.

			# Write the deployment image to disk (if it was not being done already by the download step)
			if [ -d "$SUBVOL" ]; then
				if is_btrfs_subvolume "$SUBVOL"; then
					# skip this step: the subvolume has been created already
					STATE="INSTALL"
					continue
				fi
			fi

			# Use BTRFS receive to install the image
			if [ -z ${SHOW_UI} ]; then
				echo "Installing image ${NAME}"
			else
				# TODO: verify if this really works
				whiptail --infobox "Extracting and installing system image (${NAME}). This may take some time." 10 50
			fi

			# Install the deployment from the downloaded file $IMG_FILE and place the deployed image in $DEPLOY_PATH
			TASK_MSG="Installing the downloaded deployment"
			local install_result=$(install_image "${IMG_FILE}" "${DEPLOY_PATH}")
			if echo "${install_result}" | grep -Fqx 'ERROR'; then
				TASK_ERROR=1
				TASK_ERROR_MSG="Error extracting the deployment image: ${install_result}"
				STATE="FAIL"
				continue
			fi

			STATE="INSTALL"
			;;
		"INSTALL")
			TASK_STATE="INSTALL"

			# mount home into the new deployment
			if [ -d "${SUBVOL}/home" ]; then
				local SUBVOL_HOME_MOUNT="${SUBVOL}/home"
				if is_btrfs_subvolume "${MOUNT_PATH}/home"; then
					mount --bind "${MOUNT_PATH}/home" "${SUBVOL_HOME_MOUNT}"
				elif mountpoint -q "/home"; then
					mount --bind "/home" "${SUBVOL_HOME_MOUNT}"
				else
					TASK_WARNING=1
					TASK_WARNING_MSG="Could not mount /home directory"
				fi
			fi

			# bind-mount /efi of the newly deployed image
			if [ -d "${SUBVOL}/efi" ]; then
				local SUBVOL_EFI_MOUNT="${SUBVOL}/efi"
				if [ -d "${SUBVOL_EFI_MOUNT}" ]; then
					mount --bind "${EFI_MOUNT_PATH}" "${SUBVOL_EFI_MOUNT}"
				else
					TASK_WARNING=1
					TASK_WARNING_MSG="Could not mount ESP partition because image does not have a /efi directory"
				fi
			fi

			# Execute any migrations available in the image to be deployed
			if [ -d "${SUBVOL}"/usr/lib/frzr.d ]; then
				TASK_MSG="Executing deployment migrations"
				local migrations_result=$(execute_migrations "${NAME}" "${SUBVOL}" "${MOUNT_PATH}")
				if echo "${migrations_result}" | grep -Fqx "ERROR"; then
					TASK_ERROR=1
					TASK_ERROR_MSG="Migrations on subvolume '$SUBVOL' failed: ${migrations_result}"
					STATE="FAIL"
					continue
				fi
			else
				TASK_WARNING=1
				TASK_WARNING_MSG="Could not find migrations scripts inside the deployed image"
			fi

			STATE="VERIFY"
			;;
		"VERIFY")
			TASK_STATE="VERIFY"

			# verify the subvolume integrity
			TASK_MSG="Checking integrity of deployed image"
			if [ -z "$FRZR_SKIP_CHECK" ]; then
				if ! btrfs scrub start -Bdr "${SUBVOL}"; then
					TASK_ERROR=1
					TASK_ERROR_MSG="FS check on btrfs subvolume '$SUBVOL' failed: image integrity compromised"
					STATE="FAIL"
				fi
			fi

			# Verify the system installation status, check for device quirks, and prepare for cleanup
			# Check if the FIRMWARE_OVERRIDE variable is set by the install media, if so enable firmware overrides
			#if [ -n "${FIRMWARE_OVERRIDE}" ]; then
			#	echo "export USE_FIRMWARE_OVERRIDES=1" >${MOUNT_PATH}/etc/device-quirks.conf
			#fi

			# Run frzr-tweaks to execute the device-quirks to be supplied by the deployed images
			#frzr-tweaks # TODO: pass the root as an argument and in the script default to "/"

			# Run frzr-initramfs to create mkinicpio.conf and build an initramfs
			#frzr-initramfs # TODO: review, this writes mkinitcpio.conf, make sure it stays aligned with the image one
			echo "Entering Cleanup Case"
			STATE="CLEANUP"
			;;
		"CLEANUP")
			TASK_STATE="CLEANUP"
			# Delete the downloaded system img etc.
			echo "Doing frzr-bootloader '${NAME}'"
			# This is used to update the EFI partition: setting up systemd-boot (or whatever else bootlader might be supported) to boot the new deployment
			local efi_update_result=$(frzr-bootloader "${NAME}")
			if echo "${efi_update_result}" | grep -q 'ERROR'; then
				# bootloader configuration could not be updated
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not update the EFI partition: ${efi_update_result}"
				STATE="FAIL"
				continue
			fi
			echo "Done frzr_sdboot"
			# Remove download artifacts (if any)
			rm -f ${MOUNT_PATH}/*.img.*

			# Get the subvolid: this will be used in generating the systemd-boot entry and setting is as the default for the automatic boot
			TASK_MSG="Finding deployment subvolume ID"
			local subvolid=$(btrfs_subvol_get_id "$SUBVOL")
			if echo "$subvolid" | grep -Fqx "ERROR"; then
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not find subvolume ID of the new deployment"
				STATE="FAIL"
				continue
            elif [ "${subvolid}" = "5" ]; then
                TASK_ERROR_MSG="Invalid deployment subvolid"
				STATE="FAIL"
				continue
			elif [ -z "${subvolid}" ]; then
				TASK_ERROR_MSG="Could not identify the correct subvolid of the deployment"
				STATE="FAIL"
				continue
			fi

			echo "Doing btrfs subvolume set-default \"${subvolid}\" \"${MOUNT_PATH}\""
			# Activates the new deployed image by making it the default btrfs subvolume
			# systemd-equipped initramfs images will automount the default subvolume as the rootfs
			TASK_MSG="Activating the new deployment (subvolid=${subvolid}) as the default subvolume"
			if ! btrfs subvolume set-default "${subvolid}" "${MOUNT_PATH}"; then
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not activate the new deployment"
				STATE="FAIL"
				continue
			fi
			echo "Done btrfs subvolume set-default"
			
			STATE="SUCCESS"
			;;
		"SUCCESS")
			echo "Entering SUCCESS case"
			# This state should only be used if the installation completed without errors
			TASK_STATE="SUCCESS"

			TASK_MSG="Deployment is successful: reboot to boot into ${NAME}"

			RUNNING=false
			;;
		"FAIL")
			echo "Entering FAIL case"
			# This state should only be used if the installation failed

			# TODO: clean up failed installs in the startup logic, not here!
			#if [ -d "${SUBVOL}" ]; then
			#	if is_btrfs_subvolume "${SUBVOL}"; then
			#		local deployment_removal_result=$(btrfs_filtered_subvolume_recursive_delete "${SUBVOL}" "deployments")
			#		if echo "${deployment_removal_result}" | grep -Fqx "ERROR"; then
			#			TASK_ERROR=1
			#			TASK_ERROR_MSG="Could not delete the new (errored) deployment: ${deployment_removal_result}"
			#		fi
			#	fi
			#fi

			TASK_STATE="FAIL"
			RUNNING=false
			;;
		*)
			TASK_STATE="UNKNOWN_ERROR"
			echo "ERROR: Something went terribly wrong in $(basename $0)"
			RUNNING=false
			;;
		esac
	done

	# umount the subvol /home bind-mount
	if [ ! -z "$SUBVOL_HOME_MOUNT" ]; then
		if mountpoint -q "${SUBVOL_HOME_MOUNT}"; then
			umount -l "${SUBVOL_HOME_MOUNT}"
		fi
	fi

	# umount the subvol /efi bind-mount
	if [ ! -z "$SUBVOL_EFI_MOUNT" ]; then
		if mountpoint -q "${SUBVOL_EFI_MOUNT}"; then
			umount -l "${SUBVOL_EFI_MOUNT}"
		fi
	fi

	# umount the efi path
	if [ "${MOUNTED_EFI_MOUNT_PATH}" = "yes" ]; then
		if mountpoint -q "${EFI_MOUNT_PATH}"; then
			umount -l "${EFI_MOUNT_PATH}"
		fi
	fi

	# umount the frzr_root subvolume (if it was mounted by this tool and not externally)
	if [ "${MOUNTED_MOUNT_PATH}" = "yes" ]; then
		if mountpoint -q "${MOUNT_PATH}"; then
			umount -l "${MOUNT_PATH}"
		fi
	fi
}
