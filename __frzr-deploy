#! /bin/bash

# TODO: when the refactor is ready these won't be necessary, and will prevent proper output.
set -e
set -o pipefail

# import methods
source "${BASH_SOURCE%/*}/__frzr" "$@"

main() {
	#TODO Utilize the state machine to manage the individual proccesses to send signals to external monitors
	## Signals
	#TASK_STATE="" # The current state of the state machine
	#TASK_MSG="" # TASK_MSG will be read by external tools. EX TASK_MSG="Preparing user directory"
	#TASK_TRACKER=0 # TASK_TRACKER will be used to signal back that the current TASK_MSG in queue is handled or not 0 = Pending 1 = Completed
	#TASK_ERROR=0 # Signal to let listeners know that the task had an error.
	#TASK_ERROR_MSG="" # Error message. EX: "Unexpected I/O errors found during write"
	#TASK_WARNING=0 # Signal to let listeners know there is a warning
	#TASK_WARNING_MSG="" # Warning message. EX: "BTRFS filesystem was supposed to be locked, but it was already unlocked. Continuing.."

	FRZR_CHECK_UPDATE=0
	FRZR_STEAM_PROGRESS=0
	FRZR_SOURCE=""
	FRZR_PARAMS=""

	local RUNNING=true
	local STATE="CHECK"
	echo "Entering Running loop"
	while $RUNNING; do
		case "$STATE" in
		"CHECK")
			echo "Entering Check case"
			TASK_STATE="CHECK"
			TASK_MSG="Checking for root privileges"
			if [ $EUID -ne 0 ]; then
				TASK_ERROR=1
				TASK_ERROR_MSG="$(basename $0) not run as root"
				STATE="FAIL"
			else
				TASK_MSG="Checking is system has booted via UEFI"
				check_uefi_result=$(check_uefi)
				if ! echo "${check_uefi_result}" | grep -q 'OK'; then
					TASK_ERROR=1
					TASK_ERROR_MSG="${check_uefi_result}"
					STATE="FAIL"
				else
					TASK_MSG="We are booted using UEFI"
				fi
			fi
			# Check if any updates are available and preserve FRZR parameters
			while (("$#")); do
				case $1 in
				--check)
					FRZR_CHECK_UPDATE=1
					shift
					;;
				--steam-progress)
					FRZR_STEAM_PROGRESS=1
					shift
					;;
				-* | --*)
					TASK_ERROR=1
					TASK_ERROR_MSG="Unknown argument $1"
					STATE="FAIL"
					;;
				*)                               # preserve positional arguments
					FRZR_PARAMS="${FRZR_PARAMS}$1 " # Use trailing space for the match below
					shift
					;;
				esac
			done
			echo "Entering Begin Case"
			STATE="BEGIN"
			;;
		"BEGIN")
			TASK_STATE="BEGIN"
			# keep only the first param as source
			FRZR_SOURCE="${FRZR_PARAMS%% *}"

			MOUNT_PATH=/tmp/frzr_root

			# Make sure the frzr_root is mounted during the deployment procedure
			# this code is based on the fact that when a btrfs filesystem is created
			# the default subvolid that is created contextually has the ID set to 256
			# also as a matter of fact in btrfs is impossible to change subvolumes IDs
			if ! mountpoint -q ${MOUNT_PATH} && ls -1 /dev/disk/by-label | grep frzr_root > /dev/null; then
				mkdir -p ${MOUNT_PATH}
				mount -L frzr_root -t btrfs -o subvolid=5 ${MOUNT_PATH}
				sleep 5
			fi

			if mountpoint -q ${MOUNT_PATH} && ls -1 /dev/disk/by-label | grep frzr_root > /dev/null; then
				write_log "Using '${MOUNT_PATH}' as the main subvolume mount path"

				DEPLOY_PATH=${MOUNT_PATH}/deployments
				mkdir -p ${DEPLOY_PATH}

				# TODO: check that DEPLOY_PATH exists, and if not terminate the whole procedure giving the user an error

				write_log "Using '${DEPLOY_PATH}' as the deployment destination path"

				local deploy_systemd_boot_cfg="frzr.conf"

				# Make sure the EFI partition is mounted during the deployment procedure
				local efi_root_path="${MOUNT_PATH}/efi"
				if ! mountpoint -q ${efi_root_path} && ls -1 /dev/disk/by-label | grep frzr_efi >/dev/null; then
					mkdir -p ${efi_root_path}
					mount -L frzr_efi ${efi_root_path}
					sleep 5
				fi

				# Check the "EFI System" partition is actually mounted
				if mountpoint -q ${efi_root_path} && ls -1 /dev/disk/by-label | grep frzr_efi >/dev/null; then
					BOOT_CFG="${efi_root_path}/loader/entries/${deploy_systemd_boot_cfg}"
					echo "Entering Download case"
					STATE="DOWNLOAD"
				else
					TASK_ERROR=1
					TASK_ERROR_MSG="Could not bind ${efi_root_path} to frzr_efi (boot) partition"
					STATE="FAIL"
				fi
			else
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not bind ${MOUNT_PATH} to frzr_root main subvolume"
				STATE="FAIL"
			fi
			;;
		"DOWNLOAD")
			TASK_STATE="DOWNLOAD"
			# Check if source needs updated or needs to be created for the first time
			if [ ! -z "$FRZR_SOURCE" ] && [ "$FRZR_SOURCE" != " " ] && [ $FRZR_CHECK_UPDATE -eq 0 ] && [ $FRZR_STEAM_PROGRESS -eq 0 ]; then
				echo "$FRZR_SOURCE" >"${MOUNT_PATH}/source"
			fi

			if [ -e "${MOUNT_PATH}/source" ]; then
				SOURCE=$(cat "${MOUNT_PATH}/source" | head -1)
			else
				echo "WARNING: source wasn't specified"
			fi

			if [ "${local_install}" == true ]; then
				mkdir tmp_source
				mount -o rw -L FRZR_UPDATE /root/tmp_source
				FILE_NAME=$(basename /root/tmp_source/*.img.tar.xz*)
				NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
				SUBVOL="${DEPLOY_PATH}/${NAME}"
				IMG_FILE="/root/tmp_source/${FILE_NAME}"
			elif [[ "$FRZR_SOURCE" == *".img.tar.xz" ]]; then
				FILE_NAME=$(basename ${FRZR_SOURCE})
				NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
				SUBVOL="${DEPLOY_PATH}/${NAME}"
				IMG_FILE=${FRZR_SOURCE}
			elif [[ "$FRZR_SOURCE" == *".img" ]]; then
				FILE_NAME=$(basename ${FRZR_SOURCE})
				NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
				SUBVOL="${DEPLOY_PATH}/${NAME}"
				IMG_FILE=${FRZR_SOURCE}
			else
				REPO=$(echo "${SOURCE}" | cut -f 1 -d ':')
				CHANNEL=$(echo "${SOURCE}" | cut -f 2 -d ':')

				RELEASES_URL="https://api.github.com/repos/${REPO}/releases"

				IMG_URL=$(curl --http1.1 -L -s "${RELEASES_URL}" | get_img_url "${CHANNEL}")

				if [ -z "$IMG_URL" ] || [ "$IMG_URL" == "null" ]; then
					echo "No matching source found"
					if curl --http1.1 -L -s "${RELEASES_URL}" | grep "rate limit" >/dev/null; then
						TASK_ERROR=1
						TASK_ERROR_MSG="GitHub API rate limit exceeded"
						STATE="FAIL"
					fi
					STATE="FAIL"
				fi

				FILE_NAME=$(basename ${IMG_URL})
				NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
				BASE_URL=$(dirname "${IMG_URL}")
				CHECKSUM=$(curl --http1.1 -L -s "${BASE_URL}/sha256sum.txt" | cut -f -1 -d ' ')
				SUBVOL="${DEPLOY_PATH}/${NAME}"
				IMG_FILE="${MOUNT_PATH}/${FILE_NAME}"

				if [ -e ${SUBVOL} ]; then
					TASK_ERROR=1
					TASK_ERROR_MSG="${NAME} already installed; aborting"
					STATE="FAIL"
				fi

				if [ $FRZR_CHECK_UPDATE -eq 1 ]; then
					echo "Update available: ${NAME}"
				fi

				if [ $FRZR_STEAM_PROGRESS -eq 1 ]; then
					curl --http1.1 -# -L -o "${IMG_FILE}" -C - "${IMG_URL}" 2>&1 |
						stdbuf -oL tr '\r' '\n' | grep --line-buffered -oP '[0-9]*+(?=.[0-9])' | clean_progress 91 %
				elif [ -z ${SHOW_UI} ]; then
					echo "downloading ${NAME}..."
					curl --http1.1 -L -o "${IMG_FILE}" -C - "${IMG_URL}"
				else
					curl --http1.1 -# -L -o "${IMG_FILE}" -C - "${IMG_URL}" 2>&1 |
						stdbuf -oL tr '\r' '\n' | grep --line-buffered -oP '[0-9]*+(?=.[0-9])' | clean_progress 100 |
						whiptail --gauge "Downloading system image (${NAME})" 10 50 0
				fi
			fi
			echo "Entering Chucksum Case"
			STATE="CHECKSUM"
			;;
		"CHECKSUM")
			TASK_STATE="CHECKSUM"
			TASK_MSG="Verying checksums match"
			CHECKSUM2=$(sha256sum "${IMG_FILE}" | cut -d' ' -f 1)
			if [ "$CHECKSUM" != "$CHECKSUM2" ]; then
				rm -f "${IMG_FILE}"
				echo "checksum does not match; aborting"
				# We can attempt to redownload the image again here instead of aborting like the original behavior
				TASK_ERROR=1
				TASK_ERROR_MSG="Checksum does not match"
			fi
			TASK_TRACKER=1 # Tell any listeners this task was completed, I'm not sure this variable will be needed in the end
			echo "Entering Extract Case"
			STATE="EXTRACT"
			;;
		"EXTRACT")
			TASK_STATE="EXTRACT"
			# Extract tar of system image
			# This step might not ever need to be used, but left here depending on the occasion it may be needed.
			echo "Entering Install Case"

			# Write the deployment image to disk (if it was not being done already by the download step)
			if is_btrfs_subvolume "$SUBVOL"; then
				# skip this step: the subvolume has been created already
				STATE="INSTALL"
			else
				# Use BTRFS receive to install the image
				if [ -z ${SHOW_UI} ]; then
					echo "installing ${NAME}..."
				else
					# TODO: verify if this really works
					whiptail --infobox "Extracting and installing system image (${NAME}). This may take some time." 10 50
				fi

				local install_result=$(install_image "${IMG_FILE}" "${DEPLOY_PATH}")
				if echo "${install_result}" | grep -q 'OK'; then
					STATE="INSTALL"
				else
					TASK_ERROR=1
					TASK_ERROR_MSG="Error extracting the deployment image"
					STATE="FAIL"
				fi
			fi
			;;
		"INSTALL")
			TASK_STATE="INSTALL"
			
			echo "Entering Verify Case"

			local vmlinuz_name="vmlinuz-linux"
			local initramfs_name="initramfs-linux.img"

			# Migrations should be able to modify the new installed image: set ${SUBVOL} R/W
			local set_subvol_rw=$(btrfs_subvolume_set_rw "${SUBVOL}")
			echo "Deployment Set RW: ${set_subvol_rw}"
			if echo "${set_subvol_rw}" | grep -q 'OK'; then
				# if image comes with /etc move that to /usr/etc
				if [ -d "${SUBVOL}/etc" ]; then
					mv "${SUBVOL}/etc" "${SUBVOL}/usr/etc"
				fi

				# manage /etc as a subvolume
				if [ -f "${SUBVOL}/usr/etc" ]; then
					btrfs snapshot create "${SUBVOL}/etc"
					cp -a ${SUBVOL}/usr/etc/* "${SUBVOL}/etc/"
				
				

					# Execute and migrations available in the image to be deployed
					execute_migrations "${NAME}" "${SUBVOL}" "${MOUNT_PATH}" # TODO: some old migrations are incompatible with the current model: use some newer migration scheme!

					# convert /etc/fstab label= to UUID= to avoid cross-referencing another disk
					if [ -f "${MOUNT_PATH}/root_uuid" ]; then
						local root_uuid=$(cat ${MOUNT_PATH}/root_uuid)
						sed -i -e "s/LABEL=frzr_root/UUID=${root_uuid}/" "${SUBVOL}/etc/fstab"
					else
						local disk=$(blkid -L frzr_root)
						local root_uuid=$(blkid -s UUID -o value "${disk}p2")
						sed -i -e "s/LABEL=frzr_root/UUID=${root_uuid}/" "${SUBVOL}/etc/fstab"
					fi

					STATE="VERIFY"
				else
					TASK_ERROR=1
					TASK_ERROR_MSG="No /etc directory found in the deployed image"
					STATE="FAIL"
				fi
			fi
			;;
		"VERIFY")
			TASK_STATE="VERIFY"

			# verify the subvolume integrity
			if btrfs scrub start -Bdr "$SUBVOL"; then
				# Verify the system installation status, check for device quirks, and prepare for cleanup
				# Check if the FIRMWARE_OVERRIDE variable is set by the install media, if so enable firmware overrides
				if [ -n "${FIRMWARE_OVERRIDE}" ]; then
					echo "export USE_FIRMWARE_OVERRIDES=1" >${MOUNT_PATH}/etc/device-quirks.conf
				fi

				# Run frzr-tweaks to execute the device-quirks to be supplied by the deployed images
				#frzr-tweaks # TODO: pass the root as an argument and in the script default to "/"

				# Run frzr-initramfs to create mkinicpio.conf and build an initramfs
				#frzr-initramfs # TODO: review, this writes mkinitcpio.conf, make sure it stays aligned with the image one
				echo "Entering Cleanup Case"
				STATE="CLEANUP"
			else
				TASK_ERROR=1
				TASK_ERROR_MSG="FS check on btrfs subvolume '$SUBVOL' failed: image integrity compromised"
				STATE="FAIL"
			fi
			;;
		"CLEANUP")
			TASK_STATE="CLEANUP"
			# Delete the downloaded system img etc.

			# delete deployments under these conditions:
			# - we are currently running inside a frzr deployment (i.e. not during install)
			# - the deployment is not currently running
			# - the deployment is not configured to be run on next boot
			if frzr-release >/dev/null; then
				CURRENT=$(frzr-release)
				local deployment_to_be_removed=$(get_deployment_to_delete ${CURRENT} ${BOOT_CFG} ${DEPLOY_PATH})

				if [ ! -z ${deployment_to_be_removed} ]; then
					echo "deleting ${deployment_to_be_removed}..."
					btrfs subvolume delete ${DEPLOY_PATH}/${deployment_to_be_removed} || true
					rm -rf ${MOUNT_PATH}/boot/${deployment_to_be_removed}
				fi
			fi

			# Migrations have been executed, frzr-tweaks and frzr-initramfs have been run: set the deployment subvolume back to being RO
			local set_subvol_ro=$(btrfs_subvolume_set_ro "${SUBVOL}")
			echo "Deployment Set RO: ${set_subvol_ro}"
			if echo "${set_subvol_ro}" | grep -q 'OK'; then
				# This is used to update the EFI partition: setting up systemd-boot (or whatever else bootlader might be supported) to boot the new deployment
				local efi_update_result=$(prepare_efi_partition "${NAME}" "${efi_root_path}" ${SUBVOL} "${amd_ucode}" "${intel_ucode}" "${vmlinuz_name}" "${initramfs_name}" "${additional_arguments}" "${deploy_systemd_boot_cfg}")
				echo "EFI update: ${efi_update_result}"
				if echo "${efi_update_result}" | grep -q 'OK'; then
					rm -f ${MOUNT_PATH}/*.img.*

					rm -rf /var/lib/pacman # undo frzr-unlock

					local subvolid=$(btrfs_subvol_get_id "$SUBVOL")

					if echo "$subvolid" | grep -Fqx "ERROR"; then
						TASK_ERROR=1
						TASK_ERROR_MSG="Could not find subvolume ID of the new deployment"
						STATE="FAIL"
					else
						echo "SubvolID: ${subvolid}"

						# Activates the new deployed image by making it the default btrfs subvolume, therefore what a systemd-equipped initramfs will load
						btrfs subvolume set-default "$subvolid" "${MOUNT_PATH}"

						STATE="SUCCESS"
					fi
				else # the bootloader could not be updated
					TASK_ERROR=1
					TASK_ERROR_MSG="Could not update the EFI partition"
					STATE="FAIL"
				fi
			else
				# Image could not be set back to ro: this wouldn't be a problem
				# but indicates a greater problem and it's not safe to boot to it
				# furthermore an newly deployed image is expected to be read-only
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not set the new image back in read-only state"
				STATE="FAIL"
			fi

			# umount the efi path
			umount -l ${efi_root_path}

			# umount the frzr_root subvolume
			umount -l ${MOUNT_PATH}
			;;
		"SUCCESS")
			# This state should only be used if the installation completed without errors
			TASK_STATE="SUCCESS"

			echo "deployment complete; restart to boot into ${NAME}"

			RUNNING=false
			;;
		"FAIL")
			# This state should only be used if the installation failed
			TASK_STATE="FAIL"
			RUNNING=false
			;;
		*)
			TASK_STATE="UNKNOWN_ERROR"
			echo "Something went terribly wrong"
			RUNNING=false
			;;
		esac
	done
}

if [ "$0" = "$BASH_SOURCE" ]; then
	main "$@"
fi
