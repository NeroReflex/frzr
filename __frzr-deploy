#! /bin/bash

# TODO: when the refactor is ready these won't be necessary, and will prevent proper output.
set -e
set -o pipefail

# import methods
source "${BASH_SOURCE%/*}/__frzr" "$@"

main() {
	#TODO Utilize the state machine to manage the individual proccesses to send signals to external monitors
	## Signals
	#TASK_STATE="" # The current state of the state machine
	#TASK_MSG="" # TASK_MSG will be read by external tools. EX TASK_MSG="Preparing user directory"
	#TASK_TRACKER=0 # TASK_TRACKER will be used to signal back that the current TASK_MSG in queue is handled or not 0 = Pending 1 = Completed
	#TASK_ERROR=0 # Signal to let listeners know that the task had an error.
	#TASK_ERROR_MSG="" # Error message. EX: "Unexpected I/O errors found during write"
	#TASK_WARNING=0 # Signal to let listeners know there is a warning
	#TASK_WARNING_MSG="" # Warning message. EX: "BTRFS filesystem was supposed to be locked, but it was already unlocked. Continuing.."

	FRZR_CHECK_UPDATE=0
	FRZR_STEAM_PROGRESS=0
	FRZR_SOURCE=""
	FRZR_PARAMS=""

	local RUNNING=true
	STATE="FRZR_DEPLOY_CHECK"
	while $RUNNING; do
		case "$STATE" in
		"FRZR_DEPLOY_CHECK")
			TASK_STATE="CHECK"
			TASK_MSG="Checking for root privileges"
			if [ $EUID -ne 0 ]; then
				TASK_ERROR=1
				TASK_ERROR_MSG="$(basename $0) not run as root"
				STATE="FAIL"
				continue
			fi

			TASK_MSG="Checking is system has booted via UEFI"
			check_uefi_result=$(check_uefi)
			if echo "${check_uefi_result}" | grep -Fqx 'ERROR'; then
				TASK_ERROR=1
				TASK_ERROR_MSG="UEFI boot check failed: ${check_uefi_result}"
				STATE="FAIL"
				continue
			fi
			
			# Check if any updates are available and preserve FRZR parameters
			while (("$#")); do
				case $1 in
				--check)
					FRZR_CHECK_UPDATE=1
					shift
					;;
				--steam-progress)
					FRZR_STEAM_PROGRESS=1
					shift
					;;
				-* | --*)
					TASK_ERROR=1
					TASK_ERROR_MSG="Unknown argument $1"
					STATE="FAIL"
					;;
				*)                               # preserve positional arguments
					FRZR_PARAMS="${FRZR_PARAMS}$1 " # Use trailing space for the match below
					shift
					;;
				esac
			done

			STATE="BEGIN"
			;;
		"BEGIN")
			TASK_STATE="BEGIN"
			# keep only the first param as source
			FRZR_SOURCE="${FRZR_PARAMS%% *}"

			CURRENT=$(frzr-release)

			MOUNT_PATH=/tmp/frzr_root

			# Make sure the frzr_root is mounted during the deployment procedure
			# this code is based on the fact that when a btrfs filesystem is created
			# the default subvolid that is created contextually has the ID set to 256
			# also as a matter of fact in btrfs is impossible to change subvolumes IDs
			if ! mountpoint -q ${MOUNT_PATH} && ls -1 /dev/disk/by-label | grep frzr_root > /dev/null; then
				TASK_MSG="Preparing '${MOUNT_PATH}' to be used as the main subvolume mount path"
				mkdir -p ${MOUNT_PATH}
				mount -L frzr_root -t btrfs -o subvolid=5 ${MOUNT_PATH}
				sleep 5
			fi

			if mountpoint -q ${MOUNT_PATH} && ls -1 /dev/disk/by-label | grep frzr_root > /dev/null; then
				DEPLOY_PATH=${MOUNT_PATH}/deployments

				TASK_MSG="Preparing '${DEPLOY_PATH}' to be used as the deployment destination path"

				mkdir -p ${DEPLOY_PATH}

				# Make sure DEPLOY_PATH exists
				if [ ! -d "${DEPLOY_PATH}" ]; then
					TASK_ERROR=1
					TASK_ERROR_MSG="Could not bind ${EFI_MOUNT_PATH} to frzr_efi (boot) partition"
					STATE="FAIL"
					continue
				fi

				local deploy_systemd_boot_cfg="frzr.conf"

				TASK_MSG="Preparing '${DEPLOY_PATH}' to be used as the deployment destination path"

				# Make sure the EFI partition is mounted during the deployment procedure
				EFI_MOUNT_PATH="${MOUNT_PATH}/efi"

				TASK_MSG="Preparing '${EFI_MOUNT_PATH}' to be used as the EFI System path"

				if ! mountpoint -q ${EFI_MOUNT_PATH} && ls -1 /dev/disk/by-label | grep frzr_efi >/dev/null; then
					mkdir -p ${EFI_MOUNT_PATH}
					mount -L frzr_efi ${EFI_MOUNT_PATH}
					sleep 5
				fi

				# Check the "EFI System" partition is actually mounted
				if mountpoint -q ${EFI_MOUNT_PATH} && ls -1 /dev/disk/by-label | grep frzr_efi >/dev/null; then
					BOOT_CFG="${EFI_MOUNT_PATH}/loader/entries/${deploy_systemd_boot_cfg}"
					STATE="DOWNLOAD"
				else
					TASK_ERROR=1
					TASK_ERROR_MSG="Could not bind ${EFI_MOUNT_PATH} to frzr_efi (boot) partition"
					STATE="FAIL"
				fi
			else
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not bind ${MOUNT_PATH} to frzr_root main subvolume"
				STATE="FAIL"
			fi
			;;
		"DOWNLOAD")
			TASK_STATE="DOWNLOAD"
			# Check if source needs updated or needs to be created for the first time
			if [ ! -z "$FRZR_SOURCE" ] && [ "$FRZR_SOURCE" != " " ] && [ $FRZR_CHECK_UPDATE -eq 0 ] && [ $FRZR_STEAM_PROGRESS -eq 0 ]; then
				echo "$FRZR_SOURCE" >"${MOUNT_PATH}/source"
			fi

			if [ -e "${MOUNT_PATH}/source" ]; then
				SOURCE=$(cat "${MOUNT_PATH}/source" | head -1)
			else
				echo "WARNING: source wasn't specified"
			fi

			if [ "${local_install}" == true ]; then
				mkdir tmp_source
				mount -o rw -L FRZR_UPDATE /root/tmp_source
				FILE_NAME=$(basename /root/tmp_source/*.img.tar.xz*)
				NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
				SUBVOL="${DEPLOY_PATH}/${NAME}"
				IMG_FILE="/root/tmp_source/${FILE_NAME}"
			elif [[ "$FRZR_SOURCE" == *".img.tar.xz" ]]; then
				FILE_NAME=$(basename ${FRZR_SOURCE})
				NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
				SUBVOL="${DEPLOY_PATH}/${NAME}"
				IMG_FILE=${FRZR_SOURCE}
			elif [[ "$FRZR_SOURCE" == *".img" ]]; then
				FILE_NAME=$(basename ${FRZR_SOURCE})
				NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
				SUBVOL="${DEPLOY_PATH}/${NAME}"
				IMG_FILE=${FRZR_SOURCE}
			else
				REPO=$(echo "${SOURCE}" | cut -f 1 -d ':')
				CHANNEL=$(echo "${SOURCE}" | cut -f 2 -d ':')

				RELEASES_URL="https://api.github.com/repos/${REPO}/releases"

				IMG_URL=$(curl --http1.1 -L -s "${RELEASES_URL}" | get_img_url "${CHANNEL}")

				if [ -z "$IMG_URL" ] || [ "$IMG_URL" == "null" ]; then
					if curl --http1.1 -L -s "${RELEASES_URL}" | grep "rate limit" >/dev/null; then
						TASK_ERROR=1
						TASK_ERROR_MSG="GitHub API rate limit exceeded"
						STATE="FAIL"
					else
						TASK_ERROR=1
						TASK_ERROR_MSG="No matching source found"
						STATE="FAIL"
					fi

					continue
				fi

				FILE_NAME=$(basename ${IMG_URL})
				NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
				BASE_URL=$(dirname "${IMG_URL}")
				EXPECTED_CHECKSUM=$(curl --http1.1 -L -s "${BASE_URL}/sha256sum.txt" | cut -f -1 -d ' ')
				SUBVOL="${DEPLOY_PATH}/${NAME}"
				IMG_FILE="${MOUNT_PATH}/${FILE_NAME}"

				if [ -e ${SUBVOL} ]; then

					# Only allow deleting the subvolume if we are booted in the installer.
					if [ "$UPGRADE" -eq 0 ]; then
						MSG="${NAME} is already installed, would you like to delete this and re-deploy?"
						if (whiptail --yesno "${MSG}" 10 50); then
							echo "deleting ${NAME}"
							btrfs subvolume delete ${SUBVOL}
							rm -rf "${EFI_MOUNT_PATH}/${NAME}"
						fi
					else
						TASK_ERROR=1
						TASK_ERROR_MSG="${NAME} is already installed"
						STATE="FAIL"
						continue
					fi
				fi

				if [ $FRZR_CHECK_UPDATE -eq 1 ]; then
					echo "Update available: ${NAME}"
				fi

				if [ $FRZR_STEAM_PROGRESS -eq 1 ]; then
					curl --http1.1 -# -L -o "${IMG_FILE}" -C - "${IMG_URL}" 2>&1 |
						stdbuf -oL tr '\r' '\n' | grep --line-buffered -oP '[0-9]*+(?=.[0-9])' | clean_progress 91 %
				elif [ -z ${SHOW_UI} ]; then
					echo "downloading ${NAME}"
					curl --http1.1 -L -o "${IMG_FILE}" -C - "${IMG_URL}"
				else
					curl --http1.1 -# -L -o "${IMG_FILE}" -C - "${IMG_URL}" 2>&1 |
						stdbuf -oL tr '\r' '\n' | grep --line-buffered -oP '[0-9]*+(?=.[0-9])' | clean_progress 100 |
						whiptail --gauge "Downloading system image (${NAME})" 10 50 0
				fi
			fi
			echo "Entering Chucksum Case"
			STATE="CHECKSUM"
			;;
		"CHECKSUM")
			TASK_STATE="CHECKSUM"
			TASK_MSG="Verying checksums match"
			ACTUAL_CHECKSUM=$(sha256sum "${IMG_FILE}" | cut -d' ' -f 1)
			if [ "$EXPECTED_CHECKSUM" != "$ACTUAL_CHECKSUM" ]; then
				rm -f "${IMG_FILE}"

				# We can attempt to redownload the image again here instead of aborting like the original behavior
				TASK_ERROR=1
				TASK_ERROR_MSG="Checksum does not match"
				STATE="FAIL"
				continue
			fi
			TASK_TRACKER=1 # Tell any listeners this task was completed, I'm not sure this variable will be needed in the end
			echo "Entering Extract Case"
			STATE="EXTRACT"
			;;
		"EXTRACT")
			TASK_STATE="EXTRACT"
			# Extract tar of system image
			# This step might not ever need to be used, but left here depending on the occasion it may be needed.

			# Write the deployment image to disk (if it was not being done already by the download step)
			if is_btrfs_subvolume "$SUBVOL"; then
				# skip this step: the subvolume has been created already
				STATE="INSTALL"
				continue
			fi

			# Use BTRFS receive to install the image
			if [ -z ${SHOW_UI} ]; then
				echo "Installing image ${NAME}"
			else
				# TODO: verify if this really works
				whiptail --infobox "Extracting and installing system image (${NAME}). This may take some time." 10 50
			fi

			local install_result=$(install_image "${IMG_FILE}" "${DEPLOY_PATH}")
			if echo "${install_result}" | grep -q 'ERROR'; then
				TASK_ERROR=1
				TASK_ERROR_MSG="Error extracting the deployment image: ${install_result}"
				STATE="FAIL"
			fi

			STATE="INSTALL"
			;;
		"INSTALL")
			TASK_STATE="INSTALL"
			
			local kernel_name="linux"
			if [ -f "${SUBVOL}/frzr_kernel" ]; then
				kernel_name=$(cat "${SUBVOL}/frzr_kernel")
			else
				TASK_WARNING=1
				TASK_WARNING_MSG="No kernel name specified: '${kernel_name}' will be used as the defult"
			fi

			local vmlinuz_name="vmlinuz-${kernel_name}"
			local initramfs_name="initramfs-${kernel_name}.img"

			local deployment_set_rw_result=$(btrfs_subvolume_set_rw "$SUBVOL")
			if echo "${deployment_set_rw_result}" | grep -Fqx "ERROR"; then
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not set subvolume '$SUBVOL' R/W: ${deployment_set_rw_result}"
				STATE="FAIL"
				continue
			else
				# With the filesystem unlocked create standard directories systemd can automount partitions to
				mkdir -p "${SUBVOL}/efi"
				mkdir -p "${SUBVOL}/home"
				mkdir -p "${SUBVOL}/srv"
				mkdir -p "${SUBVOL}/var"
			fi 

			# mount home into the new deployment
			if is_btrfs_subvolume "${MOUNT_PATH}/home"; then
				local home_disk_uuid=$(get_uuid "${MOUNT_PATH}/home")
				if echo "$subvolid" | grep -Fqx "ERROR"; then
					TASK_ERROR=1
					TASK_ERROR_MSG="Could not find subvolume ID of the new deployment"
					STATE="FAIL"
					continue
				fi

				mount -t btrfs -o rootflags=subvol=${MOUNT_PATH}/home,rw -U "${home_disk_uuid}" "${SUBVOL}/home"
			elif mountpoint -q "/home"
				mount --bind "/home" "${SUBVOL}/home"
			fi

			# bind-mount /efi of the newly deployed image
			if [ -d "${SUBVOL}/efi" ]; then
				mount --bind "${EFI_MOUNT_PATH}" "${SUBVOL}/efi"
			else
				TASK_WARNING=1
				TASK_WARNING_MSG="Could not mount ESP partition because image does not have a /efi directory"
			fi

			# Execute any migrations available in the image to be deployed
			TASK_MSG="Executing deployment migrations"
			local migrations_result=$(execute_migrations "${NAME}" "${SUBVOL}" "${MOUNT_PATH}")
			if echo "${migrations_result}" | grep -Fqx "ERROR"; then
				TASK_ERROR=1
				TASK_ERROR_MSG="Migrations on subvolume '$SUBVOL' failed: ${migrations_result}"
				STATE="FAIL"
				continue
			fi

			# TODO: the following code that prepare /etc and /var overlays should only be done if requested by the operating system

			# restore current /etc and /var overlays if possible or create new ones
			if echo "${CURRENT}" | grep -Fqx 'ERROR'; then
				TASK_WARNING=1
				TASK_WARNING_MSG="Error fetching the current frzr deployment: ${CURRENT}"

				btrfs subvolume create "${SUBVOL}/etc_overlay"
				btrfs subvolume create "${SUBVOL}/var_overlay"
			elif is_btrfs_subvolume "${DEPLOY_PATH}/${CURRENT}/etc_overlay" && is_btrfs_subvolume "${DEPLOY_PATH}/${CURRENT}/var_overlay"; then
				btrfs send --quiet "${DEPLOY_PATH}/${CURRENT}/etc_overlay" | btrfs receive --quiet "${SUBVOL}"
				btrfs send --quiet "${DEPLOY_PATH}/${CURRENT}/var_overlay" | btrfs receive --quiet "${SUBVOL}"
				
				local etc_overlay_set_rw=$(btrfs_subvolume_set_rw "${SUBVOL}/etc_overlay")
				if echo "etc_overlay_set_rw" | grep -Fqx "ERROR"; then
					TASK_ERROR=1
					TASK_ERROR_MSG="Could not set /etc overlay RW: ${etc_overlay_set_rw}"
					STATE="FAIL"
					continue
				fi

				local var_overlay_set_rw=$(btrfs_subvolume_set_rw "${SUBVOL}/var_overlay")
				if echo "${var_overlay_set_rw}" | grep -Fqx "ERROR"; then
					TASK_ERROR=1
					TASK_ERROR_MSG="Could not set /var overlay RW: ${var_overlay_set_rw}"
					STATE="FAIL"
					continue
				fi
			else
				TASK_WARNING=1
				TASK_WARNING_MSG="No existing overlays exists yet"

				btrfs subvolume create "${SUBVOL}/etc_overlay"
				btrfs subvolume create "${SUBVOL}/var_overlay"
			fi

			# umount the /home mount
			if mountpoint -q "${SUBVOL}/home"; then
				umount -l "${SUBVOL}/home"
			fi

			# umount the /efi bind-mount
			if mountpoint -q "${SUBVOL}/efi"; then
				umount -l "${SUBVOL}/efi"
			fi

			if is_btrfs_subvolume "${SUBVOL}/etc_overlay"; then
				mkdir -p "${SUBVOL}/etc_overlay/upper"
				mkdir -p "${SUBVOL}/etc_overlay/workdir"
			else
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not prepare the /etc overlay subvolume '${SUBVOL}/etc_overlay'"
				STATE="FAIL"
				continue
			fi

			if is_btrfs_subvolume "${SUBVOL}/var_overlay"; then
				mkdir -p "${SUBVOL}/var_overlay/upper"
				mkdir -p "${SUBVOL}/var_overlay/workdir"
			else
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not prepare the /var overlay subvolume '${SUBVOL}/var_overlay'"
				STATE="FAIL"
				continue
			fi

			STATE="VERIFY"
			;;
		"VERIFY")
			TASK_STATE="VERIFY"

			# verify the subvolume integrity
			TASK_MSG="Checking integrity of deployed image"
			if btrfs scrub start -Bdr "${SUBVOL}"; then
				# Verify the system installation status, check for device quirks, and prepare for cleanup
				# Check if the FIRMWARE_OVERRIDE variable is set by the install media, if so enable firmware overrides
				if [ -n "${FIRMWARE_OVERRIDE}" ]; then
					echo "export USE_FIRMWARE_OVERRIDES=1" >${MOUNT_PATH}/etc/device-quirks.conf
				fi

				# Run frzr-tweaks to execute the device-quirks to be supplied by the deployed images
				#frzr-tweaks # TODO: pass the root as an argument and in the script default to "/"

				# Run frzr-initramfs to create mkinicpio.conf and build an initramfs
				#frzr-initramfs # TODO: review, this writes mkinitcpio.conf, make sure it stays aligned with the image one
				echo "Entering Cleanup Case"
				STATE="CLEANUP"
			else
				TASK_ERROR=1
				TASK_ERROR_MSG="FS check on btrfs subvolume '$SUBVOL' failed: image integrity compromised"
				STATE="FAIL"
			fi
			;;
		"CLEANUP")
			TASK_STATE="CLEANUP"
			# Delete the downloaded system img etc.

			# delete deployments under these conditions:
			# - we are currently running inside a frzr deployment (i.e. not during install)
			# - the deployment is not currently running
			# - the deployment is not configured to be run on next boot
			if echo "${CURRENT}" | grep -Fqx 'ERROR'; then
				TASK_WARNING=1
				TASK_WARNING_MSG="Could not retrieve deployment to keep: ${CURRENT}"				
			else
				local deployment_to_be_removed=$(get_deployment_to_delete ${CURRENT} ${BOOT_CFG} ${DEPLOY_PATH})

				if [ ! -z ${deployment_to_be_removed} ]; then
					echo "deleting deployment ${deployment_to_be_removed}"
					btrfs subvolume delete ${DEPLOY_PATH}/${deployment_to_be_removed} || true
					rm -rf "${EFI_MOUNT_PATH}/${deployment_to_be_removed}"
				fi
			fi

			# Get the rootfs UUID: this will be used in generating the systemd-boot entry
			TASK_MSG="Finding deployment partition UUID"
			local rootfs_uuid=$(get_uuid "$SUBVOL")
			if echo "$rootfs_uuid" | grep -Fqx "ERROR"; then
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not find rootfs UUID of the new deployment"
				STATE="FAIL"
				continue
			fi

			# Get the subvolid: this will be used in generating the systemd-boot entry and setting is as the default for the automatic boot
			TASK_MSG="Finding deployment subvolume ID"
			local rootfs_subvolid=$(btrfs_subvol_get_id "$SUBVOL")
			if echo "$subvolid" | grep -Fqx "ERROR"; then
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not find subvolume ID of the new deployment"
				STATE="FAIL"
				continue
			fi

			# Read additional boot arguments (to be added to the kernel cmdline) from the deployment image
			local additional_arguments=""
			if [ -f ${SUBVOL}/usr/lib/frzr.d/bootconfig.conf ]; then
				additional_arguments="$additional_arguments $(cat ${SUBVOL}/usr/lib/frzr.d/bootconfig.conf)"
			else
				TASK_WARNING=1
				TASK_WARNING_MSG="Could not read '${SUBVOL}/usr/lib/frzr.d/bootconfig.conf': default kernel cmdline will be used"
			fi

			# This is used to update the EFI partition: setting up systemd-boot (or whatever else bootlader might be supported) to boot the new deployment
			local efi_update_result=$(prepare_efi_partition "${NAME}" "${EFI_MOUNT_PATH}" ${SUBVOL} "${amd_ucode}" "${intel_ucode}" "${vmlinuz_name}" "${initramfs_name}" "${additional_arguments}" "${deploy_systemd_boot_cfg}" "${rootfs_uuid}" "${rootfs_subvolid}")
			if echo "${efi_update_result}" | grep -q 'ERROR'; then
				# bootloader configuration could not be updated
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not update the EFI partition: ${efi_update_result}"
				STATE="FAIL"
				continue
			fi

			# Remove download artifacts (if any)
			rm -f ${MOUNT_PATH}/*.img.*

			# Activates the new deployed image by making it the default btrfs subvolume
			# systemd-equipped initramfs images will automount the default subvolume as the rootfs
			TASK_MSG="Activating the new deployment (subvolid=${subvolid}) as the default subvolume"
			if ! btrfs subvolume set-default "$subvolid" "${MOUNT_PATH}"; then
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not activate the new deployment"
				STATE="FAIL"
				continue
			fi

			STATE="SUCCESS"
			;;
		"SUCCESS")
			# This state should only be used if the installation completed without errors
			TASK_STATE="SUCCESS"

			# umount the efi path
			if mountpoint -q ${EFI_MOUNT_PATH}; then
				umount -l ${EFI_MOUNT_PATH}
			fi

			# umount the frzr_root subvolume
			if mountpoint -q ${MOUNT_PATH}; then
				umount -l ${MOUNT_PATH}
			fi

			TASK_MSG="Deployment is successful: reboot to boot into ${NAME}"

			RUNNING=false
			;;
		"FAIL")
			# This state should only be used if the installation failed
			
			# umount the efi path
			if mountpoint -q ${EFI_MOUNT_PATH}; then
				umount -l ${EFI_MOUNT_PATH}
			fi

			# umount the frzr_root subvolume
			if mountpoint -q ${MOUNT_PATH}; then
				umount -l ${MOUNT_PATH}
			fi
			
			TASK_STATE="FAIL"
			RUNNING=false
			;;
		*)
			TASK_STATE="UNKNOWN_ERROR"
			echo "Something went terribly wrong"
			RUNNING=false
			;;
		esac
	done
}

# Start the main() method like this for now since the old logic doesn't work
main "$@"

#if [ "$0" = "$BASH_SOURCE" ]; then
#	main "$@"
#fi
