#! /bin/bash

set -o pipefail

# import methods
#source "${BASH_SOURCE%/*}/__frzr" "$@"

frzr_kernel() {
	local KERNEL_NAME=""

	RUNNING=true
	STATE="BEGIN"
	while $RUNNING; do
		case "$STATE" in
		"BEGIN")
			MOUNT_PATH="/frzr_root"

			# Make sure the frzr_root is mounted during the deployment procedure
			# this code is based on the fact that when a btrfs filesystem is created
			# the default subvolid that is created contextually has the ID set to 256
			# also as a matter of fact in btrfs is impossible to change subvolumes IDs
			if mount | grep -Fq "${MOUNT_PATH}"; then
				local MOUNTED_MOUNT_PATH="no"
			else
				MOUNT_PATH="/tmp/frzr_root"
				#TASK_MSG="Preparing '${MOUNT_PATH}' to be used as the main subvolume mount path"
				mkdir -p "${MOUNT_PATH}"
				if sudo mount -L frzr_root -t btrfs -o subvolid=5,rw "${MOUNT_PATH}"; then
					local MOUNTED_MOUNT_PATH="yes"
				else
					echo "frzr-kernel failed: could not mount frzr_root"
					STATE="FAIL"
					send_data
					continue
				fi
				sleep 5
			fi

			# Make sure the EFI partition is mounted during the deployment procedure
			EFI_MOUNT_PATH="${MOUNT_PATH}/efi"

			if mount | grep -Fq "${EFI_MOUNT_PATH}"; then
				local MOUNTED_EFI_MOUNT_PATH="no"
			else
				sudo mkdir -p "${EFI_MOUNT_PATH}"
				if sudo mount -L frzr_efi -o uid=0,gid=0,fmask=0077,dmask=0077 "${EFI_MOUNT_PATH}"; then
					local MOUNTED_EFI_MOUNT_PATH="yes"
				else
					TASK_ERROR=1
					TASK_ERROR_MSG="Could not bind ${EFI_MOUNT_PATH} to frzr_efi (boot) partition"
					STATE="FAIL"
					send_data
					continue
				fi
				sleep 5
			fi

			if [ -d "${MOUNT_PATH}/kernels/usr" ]; then
				MODULES_DIR="${MOUNT_PATH}/kernels"
				KERNEL_OVERLAY_DIR="${MOUNT_PATH}/kernels"
			else
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not find kernels overlay in '${MOUNT_PATH}/kernels/usr'"
				STATE="FAIL"
				send_data
				continue
			fi

			STATE="DOWNLOAD"
			;;

		"DOWNLOAD")
			if [ ! -f ".config" ]; then
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not find kernel configuration"
				STATE="FAIL"
				send_data
				continue
			else
				cp .config .config.pre
			fi
			
			STATE="BUILD"
			;;
		
		"BUILD")
			if ! make defconfig; then
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not execute defconfig (1)"
				STATE="FAIL"
				send_data
				continue
			fi

			# Fetch the name of the kernel (uname -r)
			KERNEL_NAME=$(make -s kernelrelease)

			if ! make defconfig; then
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not execute defconfig (2)"
				STATE="FAIL"
				send_data
				continue
			fi

			echo "${KERNEL_NAME}" > version

			# This will perform a clean of previous build artifacts
			#if ! make KERNELRELEASE="${KERNEL_NAME}" mrproper; then
			#	TASK_ERROR=1
			#	TASK_ERROR_MSG="Could not execute mrproper"
			#	STATE="FAIL"
			#	send_data
			#	continue
			#fi

			cp .config.pre .config

			#echo "Checking for pre-installed kernel"
			#if [ -d "/usr/lib/modules/${KERNEL_NAME}" ]; then
			#	TASK_ERROR=1
			#	TASK_ERROR_MSG="ERROR: Kernel ${KERNEL_NAME} already exists"
			#	STATE="FAIL"
			#	continue
			#fi

			echo "Building ${KERNEL_NAME}..."

			# Get the number of available cores
			local CORES=$(nproc)
			local CORES_INT=$(echo $CORES | awk -F. '{print $1}')

			# Decide the number of cores to use based on the condition
			if [ $CORES_INT -le 16 ]; then
				MAKE_CORES=$CORES_INT
			else
				MAKE_CORES=$((CORES_INT - 2))
			fi

			# Invoke make with the determined number of cores
			if ! make -j$MAKE_CORES all; then
				TASK_ERROR=1
				TASK_ERROR_MSG="ERROR: Compilation of linux-${KERNEL_NAME} failed"
				STATE="FAIL"
				send_data
				continue
			fi

			STATE="INSTALL"
			;;
		"INSTALL")
			
			# Install kernel modules (taken from _package)
			local modulesdir="${KERNEL_OVERLAY_DIR}/usr/lib/modules/${KERNEL_NAME}"
			sudo mkdir -p "${modulesdir}"

			# systemd expects to find the kernel here to allow hibernation
			# https://github.com/systemd/systemd/commit/edda44605f06a41fb86b7ab8128dcf99161d2344
			sudo install -Dm644 "$(make -s KERNELRELEASE="${KERNEL_NAME}" image_name)" "$modulesdir/vmlinuz"

			# Used by mkinitcpio to name the kernel
			echo "$${KERNEL_NAME}" > pkgbase
			sudo install -Dm644 pkgbase "$modulesdir/pkgbase"
			rm pkgbase

			# Install modules suppressing depmod
			sudo ZSTD_CLEVEL=19 make KERNELRELEASE="${KERNEL_NAME}" INSTALL_MOD_PATH="${KERNEL_OVERLAY_DIR}/usr" INSTALL_MOD_STRIP=1 DEPMOD=/doesnt/exist modules_install

			# remove build links
			sudo rm -rf "${modulesdir}/build"

			# Install api-headers (taken from _package-api-headers)
			sudo make KERNELRELEASE="${KERNEL_NAME}" INSTALL_HDR_PATH="${KERNEL_OVERLAY_DIR}/usr" headers_install

			# Install kernel headers (taken from _package-headers)
			local builddir="${KERNEL_OVERLAY_DIR}/usr/lib/modules/${KERNEL_NAME}/build"
			sudo mkdir -p "${builddir}"

			# Install build files
			sudo install -Dt "$builddir" -m644 .config Makefile Module.symvers System.map version vmlinux

			if ls -lah | grep -Fq "localversion."; then
				for localversion in localversion.*; do
					sudo install -Dt "$builddir" -m644 "${localversion}"
				done
			fi

			sudo install -Dt "$builddir/kernel" -m644 kernel/Makefile
			sudo install -Dt "$builddir/arch/x86" -m644 arch/x86/Makefile
			sudo cp -t "$builddir" -a scripts

			# required when STACK_VALIDATION is enabled
			sudo install -Dt "$builddir/tools/objtool" tools/objtool/objtool

			# required when DEBUG_INFO_BTF_MODULES is enabled
			sudo install -Dt "$builddir/tools/bpf/resolve_btfids" tools/bpf/resolve_btfids/resolve_btfids

			# Install headers
			sudo cp -t "$builddir" -a include
			sudo cp -t "$builddir/arch/x86" -a arch/x86/include
			sudo install -Dt "$builddir/arch/x86/kernel" -m644 arch/x86/kernel/asm-offsets.s

			# sudo install -Dt "$builddir/drivers/md" -m644 drivers/md/*.h
			for file in drivers/md/*.h; do
				sudo install -Dt "$builddir/drivers/md" -m644 "$file"
			done

			# sudo install -Dt "$builddir/net/mac80211" -m644 net/mac80211/*.h
			for file in net/mac80211/*.h; do
				sudo install -Dt "$builddir/net/mac80211" -m644 "$file"
			done

			# https://bugs.archlinux.org/task/13146
			sudo install -Dt "$builddir/drivers/media/i2c" -m644 drivers/media/i2c/msp3400-driver.h

			# https://bugs.archlinux.org/task/20402
			# sudo install -Dt "$builddir/drivers/media/usb/dvb-usb" -m644 drivers/media/usb/dvb-usb/*.h
			for file in drivers/media/usb/dvb-usb/*.h; do
				sudo install -Dt "$builddir/drivers/media/usb/dvb-usb" -m644 "$file"
			done
			# sudo install -Dt "$builddir/drivers/media/dvb-frontends" -m644 drivers/media/dvb-frontends/*.h
			for file in drivers/media/dvb-frontends/*.h; do
				sudo install -Dt "$builddir/drivers/media/dvb-frontends" -m644 "$file"
			done
			# sudo install -Dt "$builddir/drivers/media/tuners" -m644 drivers/media/tuners/*.h
			for file in drivers/media/tuners/*.h; do
				sudo install -Dt "$builddir/drivers/media/tuners" -m644 "$file"
			done

			# https://bugs.archlinux.org/task/71392
			# sudo install -Dt "$builddir/drivers/iio/common/hid-sensors" -m644 drivers/iio/common/hid-sensors/*.h
			for file in drivers/iio/common/hid-sensors/*.h; do
				sudo install -Dt "$builddir/drivers/iio/common/hid-sensors" -m644 "$file"
			done

			# Install Kconfig files
			sudo find . -name 'Kconfig*' -exec install -Dm644 {} "$builddir/{}" \;

			# Remove unneeded architectures
			local arch
			for arch in "$builddir"/arch/*/; do
				[[ $arch = */x86/ ]] && continue
				echo "Removing $(basename "$arch")"
				sudo rm -r "$arch"
			done

			# Remove documentation
			sudo rm -r "$builddir/Documentation"

			# Remove broken  symlinks
			sudo find -L "$builddir" -type l -printf 'Removing %P\n' -delete

			# Remove loose objects
			sudo find "$builddir" -type f -name '*.o' -printf 'Removing %P\n' -delete

			if [ -z "${STRIP_STATIC}" ]; then
				local STRIP_STATIC="--strip-debug"
			fi

			if [ -z "${STRIP_SHARED}" ]; then
				local STRIP_SHARED="--strip-unneeded"
			fi

			if [ -z "${STRIP_BINARIES}" ]; then
				local STRIP_BINARIES="--strip-all"
			fi

			# Strip build tools
			local file
			while read -rd '' file; do
				case "$(file -Sib "$file")" in
				application/x-sharedlib\;*)      # Libraries (.so)
					sudo strip -v $STRIP_SHARED "$file" ;;
				application/x-archive\;*)        # Libraries (.a)
					sudo strip -v $STRIP_STATIC "$file" ;;
				application/x-executable\;*)     # Binaries
					sudo strip -v $STRIP_BINARIES "$file" ;;
				application/x-pie-executable\;*) # Relocatable binaries
					sudo strip -v $STRIP_SHARED "$file" ;;
				esac
			done < <(sudo find "$builddir" -type f -perm -u+x ! -name vmlinux -print0)

			# Strip vmlinux
			sudo strip -v $STRIP_STATIC "$builddir/vmlinux"

			# Add symlinks
			sudo mkdir -p "${KERNEL_OVERLAY_DIR}/usr/src"

			sudo ln -sr "$builddir" "${KERNEL_OVERLAY_DIR}/usr/src/${KERNEL_NAME}"

			STATE="INITRAMFS"
			;;
		"INITRAMFS")
			# Generate the initramfs
			if [ -d "/usr/lib/modules/${KERNEL_NAME}" ]; then
				if ! sudo mkinitcpio -c "${BASH_SOURCE%/*}/mkinitcpio.conf" -g "${EFI_MOUNT_PATH}/initramfs-frzr.img" -k "${KERNEL_NAME}" -r "${MODULES_DIR}"; then
					STATE="FAIL"
					send_data
					continue
				fi
			else
				TASK_ERROR=1
				TASK_ERROR_MSG="ERROR: The new kernel has not been installed: '/usr/lib/modules/${KERNEL_NAME}' not found"
				STATE="FAIL"
				send_data
				continue
			fi

			if ! sudo cp "$modulesdir/vmlinuz" "${EFI_MOUNT_PATH}/vmlinuz-frzr"; then
				TASK_ERROR=1
				TASK_ERROR_MSG="ERROR: Could not copy '$modulesdir/vmlinuz' to '${EFI_MOUNT_PATH}/vmlinuz-frzr'"
				STATE="FAIL"
				send_data
				continue
			fi

			STATE="BOOTLOADER"
			;;
		"BOOTLOADER")
			# Read additional boot arguments (to be added to the kernel cmdline) from the user file
			local additional_arguments=""
			if [ -f "${EFI_MOUNT_PATH}/frzr_bootconfig.conf" ]; then
				local user_bootconf_args=$(cat "${EFI_MOUNT_PATH}/frzr_bootconfig.conf") 
				additional_arguments="$additional_arguments ${user_bootconf_args}"
			else
				TASK_WARNING=1
				TASK_WARNING_MSG="Could not read '${EFI_MOUNT_PATH}/frzr_bootconfig.conf': deployment cmdline will be used"
				send_data
			fi

			# Write "${EFI_MOUNT_PATH}/loader/entries/frzr_kernel.conf" so that frzr will make use of the new kernel
			# WARNING: version being empty has special meaning
			# WARNING: btrfs_rootfs_uuid being empty means gpt-auto will be used
			local boot_entry_generation_res=$(generate_systemd_boot_cfg "" "frzr_kernel.conf" "frzr-kernel" "${EFI_MOUNT_PATH}" "no_ucode" "no_ucode" "vmlinuz-frzr" "initramfs-frzr.img" "" "")
			if echo "${boot_entry_generation_res}" | grep -Fq "ERROR"; then
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not generate systemd-boot entry: ${boot_entry_generation_res}"
				STATE="FAIL"
				send_data
				continue
			fi
			
			# This is used to update the EFI partition: setting up systemd-boot (or whatever else bootlader might be supported) to boot the new deployment
			local efi_update_result=$(frzr-bootloader)
			if echo "${efi_update_result}" | grep -Fq 'ERROR'; then
				# bootloader configuration could not be updated
				TASK_ERROR=1
				TASK_ERROR_MSG="Could not update the EFI partition: ${efi_update_result}"
				STATE="FAIL"
				send_data
				continue
			fi
			
			STATE="SUCCESS"
			;;
		"SUCCESS")
			# This state should only be used if the unlock completed without errors
			#TASK_STATE="SUCCESS"

			echo "frzr kernel deployment succeeded"

			RUNNING=false
			;;
		"FAIL")
			# This state should only be used if the unlock failed

			#TASK_STATE="FAIL"

			echo "ERROR: frzr-kernel failed: ${TASK_ERROR_MSG}"

			RUNNING=false
			;;
		*)
			TASK_STATE="UNKNOWN_ERROR"
			echo "ERROR: Something went terribly wrong in $(basename $0)"
			RUNNING=false
			;;
		esac
	done

	# umount the efi path
	if [ "${MOUNTED_EFI_MOUNT_PATH}" = "yes" ]; then
		if mountpoint -q "${EFI_MOUNT_PATH}"; then
			umount -l "${EFI_MOUNT_PATH}"
		fi
	fi

	# umount the frzr_root subvolume (if it was mounted by this tool and not externally)
	if [ "${MOUNTED_MOUNT_PATH}" = "yes" ]; then
		if mountpoint -q "${MOUNT_PATH}"; then
			umount -l "${MOUNT_PATH}"
		fi
	fi
}
