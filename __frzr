#! /bin/bash

# Check if the given directory is a btrfs subvolume
# $1 the directory
# return 0 if the directory is a subvolume, 1 otherwise
is_btrfs_subvolume() {
	local dir=$1
	[ "$(stat -f --format="%T" "$dir")" == "btrfs" ] || return 1
	inode="$(stat --format="%i" "$dir")"
	case "$inode" in
	2 | 256)
		return 0
		;;
	*)
		return 1
		;;
	esac
}

# Ensure the subvolume is in RW state
# PRE=
# POST=the directory is a btrfs subvolume in RW state
# $1 the subvolume to be changed
# stdout "OK" on success, an error string otherwise
btrfs_subvolume_set_rw() {
	local dir=${1}

	if is_btrfs_subvolume "$dir"; then
		local lock_state=$(btrfs property get -fts "$dir")
		if [[ $lock_state == *"ro=true"* ]]; then
			btrfs property set -fts ${dir} ro false

			local lock_state_after_set=$(btrfs property get -fts "$dir")
			if [[ $lock_state_after_set == *"ro=false"* ]]; then
				echo "OK"
			else
				echo "ERROR: the subvolume '$dir' is still readonly"
			fi
		else
			echo "OK"
		fi
	else
		echo "ERROR: the given argument '$dir' is not a btrfs subvolume"
	fi
}

# Ensure the subvolume is in RO state
# PRE=
# POST=the directory is a btrfs subvolume in RO state
# $1 the subvolume to be changed
# stdout "OK" on success, an error string otherwise
btrfs_subvolume_set_ro() {
	local dir=${1}

	if is_btrfs_subvolume "$dir"; then
		local lock_state=$(btrfs property get -fts "$dir")
		if [[ $lock_state == *"ro=false"* ]]; then
			btrfs property set -fts ${dir} ro true

			local lock_state_after_set=$(btrfs property get -fts "$dir")
			if [[ $lock_state_after_set == *"ro=true"* ]]; then
				echo "OK"
			else
				echo "ERROR: the subvolume '$dir' is still readonly"
			fi
		else
			echo "OK"
		fi
	else
		echo "ERROR: the given argument '$dir' is not a btrfs subvolume"
	fi
}

# Ensure the subvolume is in RO state
# PRE=
# POST=
# $1 the subvolume to be changed
# stdout SubvolID on success, an error string otherwise
btrfs_subvol_get_id() {
	local dir=${1}

	if is_btrfs_subvolume "$dir"; then
		local subvolid=$(btrfs subvolume show $dir | grep "Subvolume ID:" | cut -d ':' -f 2 | tr -d '[:space:]')

		echo $subvolid
	else
		echo "ERROR: $dir is not a valid btrfs subvolume"
	fi
}

# Install the provided image file into the given deployment directory
# $1 The path to the image file
# $2 The path to the deployment directory
# stdout "OK" on success, an error otherwise
install_image() {
	local img_file=${1}
	local deploy_path=${2}

	if [ -d "${deploy_path}" ]; then
		if [[ "${IMG_FILE##*.}" == "img" ]]; then
			btrfs receive --quiet ${DEPLOY_PATH} <${IMG_FILE}
			echo "OK"
		elif [[ "${IMG_FILE##*.}" == "zst" ]]; then
			zstd -d -c ${IMG_FILE} | btrfs receive --quiet ${DEPLOY_PATH}
			echo "OK"
		elif [[ "${IMG_FILE##*.}" == "xz" ]]; then
			if [[ "${IMG_FILE}" == *".tar.xz" ]]; then
				tar xfO ${IMG_FILE} | btrfs receive --quiet ${DEPLOY_PATH}
				echo "OK"
			else
				xz -dc ${IMG_FILE} | btrfs receive --quiet ${DEPLOY_PATH}
				echo "OK"
			fi
		else
			echo "ERROR: Unsupported file format for file '${IMG_FILE}'"
		fi
	else
		echo "ERROR: Deployment path '${deploy_path}' is not a directory"
	fi
}

# Get the newest image url for the given channel
# $1 channel (can be either "stable", "testing" or "unstable")
# stdout the image url
get_img_url() {
	local update_channel=${1}

	# Order by creation date in reverse
	result=$(jq 'sort_by(.created_at) | reverse')

	# Remove entries which have not been completed uploading
	result=$(echo "${result}" | jq 'del(.[] | select(.assets[].state != "uploaded"))')

	# Always check for stable date
	if stable_release_date=$(
		echo "${result}" | jq -er '[ .[] |
			select(.prerelease==false) ] |
			first |
			.created_at'
	); then
		# Check for stable url, this is the latest that have prerelease == false
		stable_download_url=$(
			echo "${result}" | jq -r '[ .[] |
			select(.prerelease==false) ] |
			first |
			.assets[] |
			select(.browser_download_url | test("img")) |
			.browser_download_url'
		)
	else
		# No stable channel found, pick some (old) values
		# For testing/ channel selection
		stable_release_date="1970-01-01T00:00:00Z"
		stable_download_url=""
	fi

	# Filter channels by release naming conventions
	if [[ "$update_channel" =~ ^[0-9]+\-?[0-9]*$ ]]; then
		# Check first for explicit version numbers between stable releases
		# Useful for downgrading
		result=$(
			echo "${result}" | jq -r "[ .[] |
					select(.prerelease==false) |
					select(.name|test(\" ${update_channel}\$\")) ] |
					first |
					.assets[] |
					select(.browser_download_url | test(\"img\")) |
					.browser_download_url"
		)
	elif [ "$update_channel" == "stable" ]; then
		result=$stable_download_url
	elif [ "$update_channel" == "testing" ]; then
		# Testing channel have prerelease = true and no other tags
		if testing_release_date=$(
			echo "${result}" | jq -er '[ .[] |
			select(.prerelease==true) |
			select(.name|test("\\[.*\\]")|not) ] |
			first |
			.created_at'
		); then
			testing_url=$(
				echo "${result}" | jq -r '[ .[] |
						select(.prerelease==true) |
						select(.name|test("\\[.*\\]")|not) ] |
						first |
						.assets[] |
						select(.browser_download_url | test("img")) |
						.browser_download_url'
			)
			if [ $(date -d $testing_release_date +%s) -le $(date -d $stable_release_date +%s) ]; then
				result=$stable_download_url
			else
				result=$testing_url
			fi
		else
			result=$stable_download_url
		fi
	else
		# Match any release with CHANNEL as a tag (including unstable)
		result=$(echo ${result} | jq "[ .[] | select(.prerelease==true) | select(.name|test(\"\\\[${update_channel}\\\]\" ; \"i\")) ]")
		if unstable_release_date=$(
			echo "${result}" | jq -er "[ .[] |
					select(.prerelease==true) |
					select(.name|test(\"\\\[${update_channel}\\\]\" ; \"i\")) ] |
					first |
					.created_at"
		); then
			unstable_url=$(
				echo "${result}" | jq -r "[ .[] |
						select(.prerelease==true) |
						select(.name|test(\"\\\[${update_channel}\\\]\" ; \"i\")) ] |
						first |
						.assets[] |
						select(.browser_download_url | test(\"img\")) |
						.browser_download_url"
			)
			if [ $(date -d $unstable_release_date +%s) -le $(date -d $stable_release_date +%s) ]; then
				result=$stable_download_url
			else
				result=$unstable_url
			fi
		else
			result=$stable_download_url
		fi
	fi

	echo $result
}

# Write the systemd-boot entry needed to boot the specified deployment
# Note: this function can ignore amd-ucode and intel-ucode if those are not found since mkinitcpio will place those
# in the initramfs and including them on systemd-boot is not deprecated.
# $1 the deployment version; this is also the deployment name (the name of the subvolume to be used as rootfs)
# $2 /efi mount path, the vfat partition (mind not inserting a final /)
# $3 amd_ucode.img path relative to $2/$3/ (mind not inserting a final /)
# $4 intel_ucode.img path relative to $2/$3/ (mind not inserting a final /)
# $5 vmlinuz-linux path relative to $2/$3/ (mind not inserting a final /)
# $6 initramfs-linux.img path relative to $2/$3/ (mind not inserting a final /)
# $7 additional arguments to be used in the kernel cmdline
# $8 entry config file name (mind not inserting a final /)
# stdout the configuration to be written to a systemd-boot entry to make the given deployment version bootable
# return "OK" for success, an error string otherwise
generate_systemd_boot_cfg() {
	local version=${1}
	local mount_path=${2}
	local amd_ucode=${3}
	local intel_ucode=${4}
	local vmlinuz=${5}
	local initramfs=${6}
	local additional_arguments=${7}
	local boot_entry=${8}

	local entry_conf="$mount_path/loader/entries/${boot_entry}"

	# search for the actual kernel to boot
	if [ -f ${mount_path}/${version}/${vmlinuz} ]; then
		# search fot the initramfs
		if [ -f ${mount_path}/${version}/${initramfs} ]; then
			# write title chimeraos-46_fcc653a3 (also creating the boot entry file if it doesn't exists yet)
			echo "title ${version}" | tee ${entry_conf} >/dev/null

			# write linux /chimeraos-46_fcc653a3/vmlinuz-linux
			echo "linux /${version}/${vmlinuz}" | tee --append ${entry_conf} >/dev/null

			# write /chimeraos-46_fcc653a3/amd-ucode.img if necessary
			if [ -f ${mount_path}/${version}/${amd_ucode} ]; then
				write_log "$FUNCNAME: The AMD ucode has been found at '$mount_path/$version/$amd_ucode' -- amd-ucode included in boot configuration"
				echo "initrd /${version}/${amd_ucode}" | tee --append ${entry_conf} >/dev/null
			else
				echo "# amd-ucode.img omitted" | tee --append ${entry_conf} >/dev/null
				write_log "$FUNCNAME: The AMD ucode has NOT been found at '$mount_path/$version/$amd_ucode' -- amd-ucode initrd omitted from boot configuration"
			fi

			# write /chimeraos-46_fcc653a3/intel-ucode.img if necessary
			if [ -f ${mount_path}/${version}/${intel_ucode} ]; then
				write_log "$FUNCNAME: Intel ucode has been found at '$mount_path/$version/$intel_ucode' -- intel-ucode included in boot configuration"
				echo "initrd /${version}/${intel_ucode}" | tee --append ${entry_conf} >/dev/null
			else
				echo "# intel-ucode.img omitted" | tee --append ${entry_conf} >/dev/null
				write_log "$FUNCNAME: Intel ucode has NOT been found at '$mount_path/$version/$intel_ucode' -- intel-ucode initrd omitted from boot configuration" | tee --append ${entry_conf} >/dev/null
			fi

			# write /chimeraos-46_fcc653a3/initrams-linuz.img
			echo "initrd /${version}/${initramfs}" | tee --append ${entry_conf} >/dev/null

			# write kernel cmdline
			echo "options root=gpt-auto rw quiet splash loglevel=3 rd.systemd.show_status=auto rd.udev.log_priority=3 ${additional_arguments}" | tee --append ${entry_conf} >/dev/null

			# return success
			echo "OK"
		else
			write_log "$FUNCNAME: initramfs has NOT been found at '$mount_path/$version/$initramfs'" 1

			# return the error to be printed out
			echo "ERROR: initramfs not found (searched at: '$mount_path/$version/$initramfs')"
		fi
	else
		write_log "$FUNCNAME: vmlinuz (linux kernel) has been found at '$mount_path/$version/$vmlinuz'" 1

		# return the error to be printed out
		echo "ERROR: kernel not found (searched at: '$mount_path/$version/$vmlinuz')"
	fi
}

get_deployment_to_delete() {
	local current_version=${1}
	local boot_cfg_path=${2}
	local deployment_path=${3}

	local TO_BOOT=$(get_next_boot_deployment ${current_version} ${boot_cfg_path})

	ls -1 ${deployment_path} | grep -v ${current_version} | grep -v ${TO_BOOT} | head -1 || echo
}

get_next_boot_deployment() {
	local current_version=${1}
	local boot_cfg_path=${2}

	local TO_BOOT='this-is-not-a-valid-version-string'
	if [ -f "${boot_cfg_path}" ] && grep "^title" "${boot_cfg_path}" >/dev/null; then
		TO_BOOT=$(grep ^title ${boot_cfg_path} | sed 's/title //')
	fi

	echo ${TO_BOOT}
}

clean_progress() {
	local scale=$1
	local postfix=$2
	local last_value=$scale
	while IFS= read -r line; do
		value=$((${line} * ${scale} / 100))
		if [ "$last_value" != "$value" ]; then
			echo ${value}${postfix}
			last_value=$value
		fi
	done
}

# Check that the system has been boot with UEFI
# stdout "OK" on success, an error otherwise
check_uefi() {
	if [ -d /sys/firmware/efi/efivars ]; then
		echo "OK"
	else
		write_log "$FUNCNAME: Legacy BIOS installs are not supported" 1
		echo "ERROR: Not a UEFI system"
	fi
}

# Check if there are migrations available in the image to be deployed and run them one by one
# Note: migrations are functions named post_install inside (executable) files with .migration extension
# stored inside $2/usr/lib/frzr.d/
#
# $1 the deployment version; this is also the deployment name (the name of the subvolume to be used as rootfs)
# $2 the deployment mounted subvolume: while migrations are run this has to be read-write
# $3 frzr_root the mounted path to the main btrfs subvolume (the one that contains home as a subvolume)
# stdout "OK" on success, the error otherwise
execute_migrations() {
	local version=$1
	local deployment=$2
	local frzr_root=$3

	if compgen -G "${deployment}"/usr/lib/frzr.d/*.migration >/dev/null; then
		for m in "${deployment}"/usr/lib/frzr.d/*.migration; do
			unset -f post_install
			. $m
			if [ "$(type -t post_install)" == function ]; then
				post_install "${frzr_root}" "${deployment}" "${version}"
			fi
			unset -f post_install
		done
	fi
}

# Write the systemd-boot entry needed to boot the specified deployment
# Note: this function can ignore amd-ucode and intel-ucode if those are not found since mkinitcpio will place those
# in the initramfs and including them on systemd-boot is now deprecated.
# PRE=the deployment image is available to be read from
# POST=the installed bootloader will automatically start the new deployment at boot
# $1 the deployment version; this is also the deployment name (the name of the subvolume to be used as rootfs)
# $2 /efi mount path
# $3 the path to the deployment to be booted
# $4 amd_ucode.img path relative to $2/$3/ (mind not inserting a final /)
# $5 intel_ucode.img path relative to $2/$3/ (mind not inserting a final /)
# $6 vmlinuz-linux path relative to $2/$3/ (mind not inserting a final /)
# $7 initramfs-linux.img path relative to $2/$3/ (mind not inserting a final /)
# $8 additional arguments to be used in the kernel cmdline
# $9 entry config file name (mind not inserting a final /)
# stdout the configuration to be written to a systemd-boot entry to make the given deployment version bootable
# return "OK" for success, and error string otherwise"
prepare_efi_partition() {
	local version=${1}
	local mount_path=${2}
	local deployment_root=${3}
	local amd_ucode=${4}
	local intel_ucode=${5}
	local vmlinuz_name=${6}
	local initramfs_name=${7}
	local additional_arguments=${8}
	local boot_entry=${9}

	# create /loader/entries in the EFI system partition (if it does not exists already)
	mkdir -p ${efi_root_path}/loader/entries

	if [ -d "${efi_root_path}/loader/entries" ]; then
		if [ -f ${deployment_root}/boot/${vmlinuz_name} ]; then
			if [ -f ${deployment_root}/boot/${initramfs_name} ]; then
				# each deployment will need its own kernel as well as initramfs to boot: place them in a EFI subdirectory
				mkdir -p ${efi_root_path}/${version}

				if [ -d "${efi_root_path}/${version}" ]; then
					if [ -f "$SUBVOL/etc/mkinitcpio" ] && cat "$SUBVOL/etc/mkinitcpio" | grep "HOOKS" | grep -Fqx "systemd"; then
						echo "systemd hook has boon found"
					else
						# TODO: see https://wiki.archlinux.org/title/Mkinitcpio
						# TODO: use sed to add systemd hooks replacing udev, usr and resume, and sd-vconsole replacing consolefont and keymap
						# TODO: use the image mkinitcpio to regenerate the initramfs
					fi

					# Read additional boot arguments (to be added to the kernel cmdline) from the deployment image
					local additional_arguments=""
					if [ -f ${deployment_root}/usr/lib/frzr.d/bootconfig.conf ]; then
						additional_arguments="$additional_arguments $(cat ${deployment_root}/usr/lib/frzr.d/bootconfig.conf)"
					else
						write_log "$FUNCNAME: File '${deployment_root}/usr/lib/frzr.d/bootconfig.conf' has not been found. No additional boot arguments will be set." 2
					fi

					if [ -f "$SUBVOL/etc/mkinitcpio" ] && cat "$SUBVOL/etc/mkinitcpio" | grep "HOOKS" | grep -Fqx "ucode"; then
						echo "ucode hook has been found"
					else
						local amd_ucode="amd-ucode.img"
						if [ -e ${deployment_root}/boot/amd-ucode.img ]; then
							cp ${deployment_root}/boot/amd-ucode.img ${efi_root_path}/${version}/${amd_ucode}
						fi
					fi

					if [ -f "$SUBVOL/etc/mkinitcpio" ] && cat "$SUBVOL/etc/mkinitcpio" | grep "HOOKS" | grep -Fqx "ucode"; then
						echo "ucode hook has boon found"
					else
						local intel_ucode="intel-ucode.img"
						if [ -e ${deployment_root}/boot/intel-ucode.img ]; then
							cp ${deployment_root}/boot/intel-ucode.img ${efi_root_path}/${version}/${intel_ucode}
						fi
					fi

					# Following steps copy kernel, initramfs and ucode to the EFI partition to be used on the next boot
					cp ${deployment_root}/boot/${vmlinuz_name} ${efi_root_path}/${version}/${vmlinuz_name}
					cp ${deployment_root}/boot/${initramfs_name} ${efi_root_path}/${version}/${initramfs_name}

					local systemd_boot_update_result=$(generate_systemd_boot_cfg "${version}" "${mount_path}" "${amd_ucode}" "${intel_ucode}" "${vmlinuz_name}" "${initramfs_name}" "${additional_arguments}" "${boot_entry}")
					echo "systemd-boot install: ${systemd_boot_update_result}"

					if echo "${systemd_boot_update_result}" | grep -q 'OK'; then
						echo "default ${boot_entry}" >${mount_path}/loader/loader.conf

						echo "OK"
					else
						echo "${systemd_boot_update_result}"
					fi
				else
					echo "ERROR: could not create path '${efi_root_path}/${version}' system will not be bootable"
				fi
			else
				# searched at should be mount/deployment/chimeraos_XX-YYYYYY/boot/initramfs-linux.img
				echo "ERROR: Could not find initramfs (searched at: '$deployment_root/boot/$initramfs_name')"
			fi
		else
			# searched at should be mount/deployment/chimeraos_XX-YYYYYY/boot/vmlinuz-linux
			echo "ERROR: Could not find vmlinuz (searched at: '$deployment_root/boot/$vmlinuz_name')"
		fi
	else
		echo "ERROR: could not create path '${efi_root_path}/loader/entries' system will not be bootable"
	fi
}
